# Цикли while і for

При написанні скриптів часто постає завдання зробити однотипне дію багато разів.

Наприклад, вивести товари зі списку один за іншим. Або просто перебрати всі числа від `1` до` 10` і для кожного виконати однаковий код.

Для багаторазового повторення однієї ділянки коду передбачені цикли.

## Цикл "while"

Цикл `while` має наступний синтаксис:

```
while (condition) {
  // код
  // також званий "тілом циклу"
}
```

Код з тіла циклу виконується, поки умова `condition` істинно.

Наприклад, цикл нижче виводить `i`, поки` i <3 `:

```
let i = 0;
while (i <3) {// виводить 0, потім 1, потім 2
  alert (i);
  i ++;
}
```

Одне виконання тіла циклу по-науковому називається * ітерація *. Цикл в прикладі вище робить три ітерації.

Якби рядок `i ++` була відсутня в прикладі вище, то цикл б повторювався (в теорії) вічно. На практиці, звичайно, браузер не дозволить такому трапитися, він надасть користувачеві можливість зупинити "підвішеному" скрипт, а JavaScript на стороні сервера доведеться "вбити" процес.

Будь-яке вираження або змінна може бути умовою циклу, а не тільки порівняння: умова `while` обчислюється і перетворюється в логічне значення.

Наприклад, `while (i)` - більш короткий варіант `while (i! = 0)`:

```
let i = 3;
*! *
while (i) {// коли i дорівнюватиме 0, умова стане хибним, і цикл зупиниться
* /! *
  alert (i);
  i--;
}
```

Smart header = "Фігурні дужки не потрібні для тіла циклу з одного рядка"
Якщо тіло циклу складається лише з однієї інструкції, ми можемо опустити фігурні дужки `{...}`:

```
let i = 3;
*! *
while (i) alert (i--);
* /! *
```


## Цикл "do ... while"

Перевірку умови можна розмістити під тілом циклу, використовуючи спеціальний синтаксис `do..while`:

```
do {
  // тіло циклу
} While (condition);
```

Цикл спочатку виконає тіло, а потім перевірить умова `condition`, і поки його значення дорівнює` true`, він буде виконуватися знову і знову.

наприклад:

```
let i = 0;
do {
  alert (i);
  i ++;
} While (i <3);
```

Така форма синтаксису виправдана, якщо ви хочете, щоб тіло циклу виповнилося ** хоча б один раз **, навіть якщо умова виявиться помилковим. На практиці частіше використовується форма з передумовою: `while (...) {...}`.

## Цикл "for"

Більш складний, але при цьому найпоширеніший цикл - цикл `for`.

Виглядає він так:

```Js
for (початок; умова; крок) {
  // ... тіло циклу ...
}
```

Давайте розберемося, що означає кожна частина, на прикладі. Цикл нижче виконує `alert (i)` для `i` від` 0` до (але не включаючи) `3`:

```
for (let i = 0; i <3; i ++) {// виведе 0, потім 1, потім 2
  alert (i);
}
```

Розглянемо конструкцію `for` детальніше:

| частина | | |
| ------- | ---------- | ------------------------------ ---------------------------------------------- |
| * Початок * | `I = 0` | Виконується один раз при вході в цикл |
| * Умова * | `I <3` | Перевіряється * перед * кожної итерацией циклу. Якщо воно обчислити в `false`, цикл зупиниться. |
| * Крок * | `I ++` | Виконується * після * тіла циклу на кожній ітерації * перед * перевіркою умови. |
| * Тіло * | `Alert (i)` | Виконується знову і знову, поки умова обчислюється в `true`. |

В цілому, алгоритм роботи циклу виглядає наступним чином:

```
Виконати * початок *
→ (Якщо * умова * == true → Виконати * тіло *, Виконати * крок *)
→ (Якщо * умова * == true → Виконати * тіло *, Виконати * крок *)
→ (Якщо * умова * == true → Виконати * тіло *, Виконати * крок *)
→ ...
```

Тобто, * початок * виконується один раз, а потім кожна ітерація полягає в перевірці * умови *, після якої виконується * тіло * і * крок *.

Якщо тема циклів для вас нова, може бути корисним повернутися до прикладу вище і відтворити його роботу на аркуші паперу, крок за кроком.

Ось в точності те, що відбувається в нашому випадку:

```
// for (let i = 0; i <3; i ++) alert (i)

// Виконати початок
let i = 0;
// Якщо умова == true → Виконати тіло, Виконати крок
if (i <3) {alert (i); i ++}
// Якщо умова == true → Виконати тіло, Виконати крок
if (i <3) {alert (i); i ++}
// Якщо умова == true → Виконати тіло, Виконати крок
if (i <3) {alert (i); i ++}
// ... кінець, тому що тепер i == 3
```

Smart header = "Вбудоване оголошення змінної"
У прикладі змінна лічильника `i` була оголошена прямо в циклі. Це так зване "вбудоване" оголошення змінної. Такі змінні існують тільки всередині циклу.

```
for (*! * let * /! * i = 0; i <3; i ++) {
  alert (i); // 0, 1, 2
}
alert (i); // помилка, немає такої змінної
```

Замість оголошення нової змінної ми можемо використовувати вже існуючу:

```
let i = 0;

for (i = 0; i <3; i ++) {// використовуємо існуючу змінну
  alert (i); // 0, 1, 2
}

alert (i); // 3, змінна доступна, тому що була оголошена зовні циклу
```









### Пропуск частин "for"

Будь-яка частина `for` може бути пропущена.

Для прикладу, ми можемо пропустити `начало` якщо нам нічого не потрібно робити перед стартом циклу.

Ось так:

```
let i = 0; // ми вже маємо оголошену i з присвоєним значенням

for (; i <3; i ++) {// немає необхідності в "початку"
  alert (i); // 0, 1, 2
}
```

Можна прибрати і `шаг`:

```
let i = 0;

for (; i <3;) {
  alert (i ++);
}
```

Це зробить цикл аналогічним `while (i <3)`.

А можна і взагалі прибрати все, отримавши нескінченний цикл:

```
for (;;) {
  // буде виконуватися вічно
}
```

При цьому самі крапки з комою `;` обов'язково повинні бути присутніми, інакше нічого не вийде синтаксису.

## Переривання циклу: "break"

Зазвичай цикл завершується при обчисленні * умови * в `false`.

Але ми можемо вийти з циклу в будь-який момент за допомогою спеціальної директиви `break`.

Наприклад, наступний код підраховує суму чисел, що вводяться до тих пір, поки відвідувач їх вводить, а потім - видає:

```
let sum = 0;

while (true) {

  let value = + prompt ( "Введіть число", '');

*! *
  if (! value) break; // (*)
* /! *

  sum + = value;

}
alert ( 'Сума:' + sum);
```

Директива `break` в рядку `(*)` повністю припиняє виконання циклу і передає управління на рядок за його тілом, тобто на `alert`.

Взагалі, поєднання «нескінченний цикл + `break` »- відмінна штука для тих ситуацій, коли умова, за яким потрібно перерватися, знаходиться не на початку або наприкінці циклу, а посередині.

## Перехід до наступної ітерації: continue [#continue]

Директива `continue` - "полегшена версія" `break`. При її виконанні цикл не переривається, а переходить до наступної ітерації (якщо умова все ще одно `true`).

Її використовують, якщо зрозуміло, що на поточному повторі циклу робити більше нічого.

Наприклад, цикл нижче використовує `continue`, щоб виводити тільки непарні значення:

```
for (let i = 0; i <10; i ++) {

  // якщо true, пропустити решту тіла циклу
  *! * If (i% 2 == 0) continue; * /! *

  alert (i); // 1, потім 3, 5, 7, 9
}
```

Для парних значень `i`, директива` continue` припиняє виконання тіла циклу і передає управління на наступну ітерацію `for` (з наступним числом). Таким чином `alert` викликається тільки для непарних значень.

Smart header = "Директива` continue` дозволяє уникати вкладеності "
Цикл, який обробляє тільки непарні значення, міг би виглядати так:

```
for (let i = 0; i <10; i ++) {

  if (i% 2) {
    alert (i);
  }

}
```

З технічної точки зору він повністю ідентичний. Дійсно, замість `continue` можна просто загорнути дії в блок` if`.

Однак ми отримали додатковий рівень вкладеності фігурних дужок. Якщо код всередині `if` довший, то це погіршує читаність, на відміну від варіанту з `continue`.


Warn header = "Не можна використовувати `break / continue` праворуч від оператора '?' "
Зверніть увагу, що ці синтаксичні конструкції не є виразами і не можуть бути використані з тернарного оператором `?`. Зокрема, використання таких директив, як `break / continue`, викличе помилку.

Наприклад, якщо ми візьмемо цей код:

```
if (i> 5) {
  alert (i);
} Else {
  continue;
}
```

... і перепишемо його, використовуючи знак питання:


```
(I> 5)? alert (i): *! * continue * /! *; // continue тут призведе до помилки
```

... то буде синтаксична помилка.

Це ще один привід не використовувати оператор знаку `?` Замість `if`.



## Мітки для break / continue

Буває, потрібно вийти одночасно з декількох рівнів циклу відразу.

Наприклад, в коді нижче ми проходимся циклами по `i` і `j`, запитуючи за допомогою `prompt` координати `(i, j)` з `(0,0)` до `(2,2)`:

```
for (let i = 0; i <3; i ++) {

  for (let j = 0; j <3; j ++) {

    let input = prompt ( `Значення на координатах ($ {i}, $ {j})`, '');

    // Що якщо ми захочемо перейти до Готово (нижче) прямо звідси?

  }
}

alert ( 'Готово!');
```

Нам потрібен спосіб зупинити виконання якщо користувач скасує введення.

Звичайний `break` після `input` лише перерве внутрішній цикл, але цього недостатньо. Досягти бажаного поведінки можна за допомогою міток.

* Позначка * має вигляд ідентифікатора з двокрапкою перед циклом:
```
labelName: for (...) {
  ...
}
```

Виклик `break <labelName>` в циклі нижче шукає найближчий зовнішній цикл з такою міткою і переходить в його кінець.

```
*! * Outer: * /! * For (let i = 0; i <3; i ++) {

  for (let j = 0; j <3; j ++) {

    let input = prompt ( `Значення на координатах ($ {i}, $ {j})`, '');

    // якщо порожній рядок або Скасування, то вийти з обох циклів
    if (! input) *! * break outer * /! *; // (*)

    // зробити що-небудь зі значеннями ...
  }
}

alert ( 'Готово!');
```

В наведеному вище прикладі це означає, що викликом `break outer` буде розірваний зовнішній цикл до мітки з ім'ям` outer`, і управління перейде зі рядки з позначкою `(*)`, до `alert ( 'Готово!')`.

Можна розміщувати мітку на окремому рядку:

```
outer:
for (let i = 0; i <3; i ++) {...}
```

Директива `continue` також може бути використана з міткою. У цьому випадку управління перейде на наступну ітерацію циклу з міткою.

Warn header = "Мітки не дозволяють \" стрибнути \ "куди завгодно"
Мітки не дають можливості передавати управління в довільне місце коду.

Наприклад, немає можливості зробити наступне:
```
break label; // не стрибає до мітки нижче

label: for (...)
```

Виклик `break / continue` можливий тільки всередині циклу, і мітка повинна знаходитися десь вище цієї директиви.


## Разом

Ми розглянули 3 види циклів:

- `while` - Перевіряє умова перед кожною итерацией.
- `do..while` - Перевіряє умова після кожної ітерації.
- `for (;;)` - Перевіряє умова перед кожною итерацией, є можливість задати додаткові налаштування.

Щоб організувати нескінченний цикл, використовують конструкцію `while (true)`. При цьому він, як і будь-який інший цикл, може бути перерваний директивою `break`.

Якщо на даній ітерації циклу робити більше нічого не треба, але повністю припиняти цикл не слід - використовують директиву `continue`.

Обидві ці директиви підтримують * мітки *, які ставляться перед циклом. Мітки - єдиний спосіб для `break / continue` вийти за межі поточного циклу, вплинути на виконання зовнішнього.

Зауважимо, що мітки не дозволяють стрибнути в довільне місце коду, в JavaScript немає такої можливості.




