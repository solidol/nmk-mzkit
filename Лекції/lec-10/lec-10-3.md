# Конструкція "switch"

Конструкція `switch` замінює собою відразу кілька `if`.

Вона являє собою більш наочний спосіб порівняти вираз відразу з декількома варіантами.

## Синтаксис

Конструкція `switch` має один або більше блок `case` і необов'язковий блок `default`.

Виглядає вона так:

```
switch (x) {
  case 'value1': // if (x === 'value1')
    ...
    [Break]

  case 'value2': // if (x === 'value2')
    ...
    [Break]

  default:
    ...
    [Break]
}
```

- Змінна `x` перевіряється на суворе рівність першому значенню `value1`, потім другого `value2` і так далі.
- Якщо відповідність встановлено - `switch` починає виконуватися від відповідної директиви `case` і далі, до найближчого `break` (або до кінця `switch`).
- Якщо жоден `case` не співпали - виконується (якщо є) варіант `default`.

## Приклад роботи

Приклад використання `switch` (спрацював код виділений):

```
let a = 2 + 2;

switch (a) {
  case 3:
    alert ( 'Малувато');
    break;
*! *
  case 4:
    alert ( 'В точку!');
    break;
* /! *
  case 5:
    alert ( 'Перебір');
    break;
  default:
    alert ( "Немає таких значень");
}
```

Тут оператор `switch` послідовно порівняє `a` з усіма варіантами з `case`.

Спочатку `3`, потім - так як немає збігу - `4`. Збіг знайдено, буде виконаний цей варіант, з рядка `alert('В точку!')` І далі, до найближчого `break`, який перерве виконання.

** Якщо `break` немає, то виконання піде нижче за наступними `case`, при цьому інші перевірки ігноруються. **

Приклад без `break`:

```
let a = 2 + 2;

switch (a) {
  case 3:
    alert ( 'Малувато');
*! *
  case 4:
    alert ( 'В точку!');
  case 5:
    alert ( 'Перебір');
  default:
    alert ( "Немає таких значень");
* /! *
}
```

В наведеному вище прикладі послідовно виконуватися три `alert`:

```
alert ( 'В точку!');
alert ( 'Перебір');
alert ( "Немає таких значень");
```

Smart header = "Будь-яке вираження може бути аргументом для `switch / case` "
І `switch` і `case` допускають будь-який вираз в якості аргументу.

наприклад:

```
let a = "1";
let b = 0;

switch (+ a) {
*! *
  case b + 1:
    alert ( "Виконати, тому що значенням + a буде 1, що в точності так само b + 1");
    break;
* /! *

  default:
    alert ( "Це не виконається");
}
```
У цьому прикладі вираз `+a `обчислюється в `1`, що збігається з виразом `b + 1` в `case`, і отже, код в цьому блоці буде виконаний.


## Угруповання "case"

Кілька варіантів `case`, що використовують один код, можна групувати.

Для прикладу, виконаємо один і той же код для `case 3` і `case 5`, згрупувавши їх:

```
let a = 2 + 2;

switch (a) {
  case 4:
    alert ( 'Правильно!');
    break;

*! *
  case 3: // (*) групуємо обидва case
  case 5:
    alert ( 'Неправильно!');
    alert ( "Може вам відвідати урок математики?");
    break;
* /! *

  default:
    alert ( 'Результат виглядає трохи дивно. Чесно.');
}
```

Тепер обидва варіанти `3 ` і `5` виводять одне повідомлення.

Можливість групувати `case `- це побічний ефект того, як `switch / case `працює без `break`. Тут виконання `case 3 `починається з рядка `(*)` і триває в `case 5`, тому що відсутня `break`.

## Тип має значення

Потрібно відзначити, що перевірка на рівність завжди сувора. Значення повинні бути одного типу, щоб виконувалося рівність.

Для прикладу, давайте розглянемо наступний код:

```
let arg = prompt ( "Введіть число?");
switch (arg) {
  case '0':
  case '1':
    alert ( 'Один або нуль');
    break;

  case '2':
    alert ( 'Два');
    break;

  case 3:
    alert ( 'Ніколи не виконається!');
    break;
  default:
    alert ( 'Невідоме значення');
}
```

1. Для `'0'` і `' 1'` виконається перший `alert`.
2. Для `'2'` - другий `alert`.
3. Але для `3`, результат виконання `prompt `буде рядок `"3"`, яка не відповідає суворому рівності `===` з числом`3`. Таким чином, ми маємо "мертвий код" в `case 3`! Виконається варіант `default`.