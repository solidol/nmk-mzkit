# Безпека інформації в мережі Internet

## Перелік лекцій
1.  [Структура HTML-документа і елементи розмітки заголовка документа](lec-01.md)
2.  [Безпека інформації в мережі Internet](lec-02.md)
3.  [Контейнери тіла документа. Таблиці](lec-03.md)
4.  [Використання стилів CSS для налаштування зовнішнього вигляду документу](lec-04.md)
5.  [Основи блочного верстання документів](lec-05.md)
6.  [Основи адаптивної верстки](lec-06.md)
7.  [Створення інтерфейсів за допомогою фреймворку Bootstrap](lec-07.md)
8.  [Створення мобільних інтерфейсів за допомогою фреймворку Bootstrap ч. 2](lec-08.md)
9.  [Типи даних та перетворення типів](lec-09.md)
10.  [Конструкції мови JavaScript](lec-10.md)
11.  [Створення користувацьких функцій](lec-11.md)
12.  [Об'єкти та методи у мові JavaScript](lec-12.md)
13.  [Об'єктна нотація JSON](lec-13.md)
14.  [Технологія асинхронного обміну даними AJAX](lec-14.md)
15.  [Бібліотека jQuery](lec-15.md)
16.  [Плагіни бібліотеки jQuery](lec-16.md)


## Зміст лекції

1.  [Мета шифрування HTTP](#'Мета шифрування HTTP')
2.  [Протокол SSL](#'Протокол SSL')
3.  [Протокол TLS](#'Протокол TLS')
4.  [Теми для самостійного вивчення](#'Теми для самостійного вивчення')
5.  [Контрольні питання](#'Контрольні питання')



## Мета шифрування HTTP

Найчастіше протокол HTTP використовується в складі будь-якого Інтернет-ресурсу, який здійснює маніпуляції з особистими або фінансовими даними його користувачів, що відвідують Інтернет. Найчастіше це банки, Інтернет-магазини або будь-які інші віртуальні місця, в яких користувачі, що приходять, вимушені передавати свої особисті, а іноді секретні дані. Цього може вимагати і проста реєстрація, і процедура оплати товару, або будь-яка інша процедура, при якій користувачі примушені видавати свої паспортні дані, PIN-коди і паролі. Використовуючи звичайний HTTP-протокол, користувач передає й одержує інформацію в чистому, незашифрованому вигляді. Отже, інформація, що передається користувачем, може бути легко перехоплена і використана сторонньою людиною.

Окрім цього, існує й інша, на перший погляд незначна, загроза. Уявіть, що банк користувача розміщений за адресою http://MyHomeBank.com. Тепер уявімо, що деякий зловмисник реєструє іншу адресу, скажімо http://MyHOmeBank.com, і створює з нею сайт, зовні схожий на сайт банку користувача. Ці адреси так схожі, що рано чи пізно користувач напевно помилиться і випадково потрапить не в банк, а на сайт зловмисника.

Із зазначеного випливають два досить важливих висновки:

1.  перший — інформацію, що передається, треба шифрувати;
2.  другий — ми повинні бути впевнені, що передаємо інформацію саме туди, куди потрібно.

Саме для вирішення цих двох питань і використовується технологія SSL. Розглянемо принцип дії безпечних протоколів.

## Протокол SSL

SSL (secure sockets layer - рівень захищених сокетів) - криптографічний протокол сеансового рівня для забезпечення безпечної зв'язку. Використовує асиметричну криптографію для аутентифікації ключів обміну, симетричне шифрування для збереження конфіденційності та коди аутентифікації повідомлень для цілісності повідомлень.

В даний час протокол вважається небезпечним і повинен бути замінений на протокол TLS, який є його подальшим розвитком. Протокол SSL надає "безпечний канал", який має три основні властивості:

*   Канал є приватним. Шифрування використовується для всіх повідомлень після простого діалогу, який служить для визначення секретного ключа.
*   Канал аутентифікований. Серверна сторона діалогу завжди аутентифицирующей, а клієнтська робить це опционно.
*   Канал надійний. Транспортування повідомлень включає в себе перевірку цілісності.

SSL незалежний від прикладного протоколу. Протоколи прикладного рівня (HTTP, FTP, TELNET і т.д.) можуть працювати над протоколом SSL абсолютно прозоро - SSL може погоджувати алгоритм шифрування і ключ сесії, а також аутентифицировать сервер до того, як додаток прийме або передасть перший байт повідомлення.

Протокол SSL був спочатку розроблений компанією Netscape Communications. Версія 1.0 ніколи не була оприлюднена. Версії 2.0 була випущена в лютому 1995 року, але містила багато недоліків з безпеки, які призвели до розробки SSL версії 3.0. SSL версії 3.0, випущений в 1996 році, послужив основою для створення протоколу TLS 1.0, стандарт протоколу Internet Engineering Task Force (IETF), який вперше був визначений в RFC 2246 в січні 1999 року. TLS 1.1 був представлений в RFC 4346 в квітні 2006 року. У серпні 2008 року в RFC 5246 був анонсований TLS 1.2.

SSL використовує середовище з декількома шарами, що забезпечує безпеку обміну інформацією. Конфіденційність спілкування присутній за рахунок того, що безпечне з'єднання відкрито тільки цільовим користувачам. Протокол SSL розміщується між двома протоколами: протоколом, який використовує програма-клієнт (HTTP, FTP, TELNET) і транспортним протоколом TCP / IP. Роботу протоколу можна розділити на два рівні:

1.  Шар протоколу підтвердження підключення (Handshake Protocol Layer)
2.  Шар протоколу записи

Перший шар, в свою чергу, складається з трьох подпротоколов:

2.  Протокол підтвердження підключення (Handshake Protocol)
3.  Протокол зміни параметрів шифру (Cipher Spec Protocol)
4.  Попереджувальний протокол (Alert Protocol)

Протокол підтвердження підключення використовується для узгодження даних сесії між клієнтом і сервером. До даних сесії відносяться:

*   ID сесії
*   Алгоритм стиснення інформації
*   Сертифікати обох сторін
*   Інформація для створення симетрії.
*   Параметри алгоритму шифрування ключів; відкритий ключ
    

Протокол зміни параметрів шифру використовується для зміни даних ключа (keyingmaterial) - інформації, яка використовується для створення ключів шифрування. Протокол складається всього з одного повідомлення, в якому сервер каже, що відправник хоче змінити набір ключів.

Попереджувальний протокол містить повідомлення, яке показує сторонам зміна статусу або повідомляє про можливу помилку. Зазвичай попередження відсилається тоді, коли підключення закрито і отримано неправильне повідомлення, повідомлення неможливо розшифрувати або користувач скасовує операцію.

Протокол підтвердження підключення виробляє ланцюжок обміну даними, що в свою чергу починає аутентифікацію сторін і погоджує шифрування, хешування і стиснення. Наступний етап - аутентифікація учасників, яка здійснюється також протоколом підтвердження підключення.

Для перевірки з'єднання SSL використовує сертифікати. Сертифікати розташовані на безпечній сервері і використовуються для шифрування даних та ідентифікації Web-сайту.

Способи отримання SSL-сертифіката:

*   Використовувати сертифікат, виданий центром сертифікації
*   Використовувати самоподпісанний сертифікат - сертифікат, створений самим користувачем - в цьому випадку видавець сертифіката збігається з власником сертифікату.
*   Використовувати "порожній" сертифікат - сертифікат, що містить фіктивну інформацію, яка у ролі тимчасової для настройки SSL і перевірки його функціональності в даному середовищі.

Центр сертифікації або засвідчує центр (Certification authority, CA) - сторона (відділ, організація), чия чесність незаперечна, а відкритий ключ широко відомий. Завдання центру сертифікації - підтверджувати справжність ключів шифрування за допомогою сертифікатів електронного підпису, що мають наступну структуру:

*   серійний номер сертифіката;
*   об'єктний ідентифікатор алгоритму електронного підпису;
*   ім'я посвідчує центру;
*   термін дії сертифіката;
*   ім'я власника сертифіката (ім'я користувача, якому належить сертифікат);
*   відкриті ключі власника сертифіката (ключів може бути кілька);
*   об'єктні ідентифікатори алгоритмів, асоційованих з відкритими ключами власника сертифіката;
*   електронний підпис, згенерувала з використанням секретного ключа посвідчує центру (підписується результат хешування всієї інформації, що зберігається в сертифікаті).

Механізми утворення ключа для поточної сесії в SSL / TLS

1. RSA. При втраті приватного ключа криптоаналитик отримує можливість розшифрувати всі записані минулі повідомлення і майбутні повідомлення.
2. Fixed Diffie-Hellman. Використовує постійний публічний ключ, який прописаний в сертифікаті сервера. При кожному новому з'єднанні, клієнт надає свою частину ключа. Після обміну ключами, утворюється новий симетричний ключ для обміну інформацією для поточної сесії. При розкритті приватного ключа сервера, криптоаналитик зможе розшифрувати раніше записані повідомлення, а також всі майбутні повідомлення.
3. Anonymous Diffie-Hellman. Чи не надає гарантій секретності, бо дані передаються незашифрованими.
4. Ephemeral Diffie-Hellman. Гарантує безпеку минулих і майбутніх повідомлень. При кожному новому з'єднанні сервером і клієнтом створюється одноразовий ключ. Навіть якщо криптоаналітику дістанеться поточний приватний ключ, він зможе розшифрувати тільки поточну сесію, але не попередні або майбутні сесії.

## Протокол діалогу SSL

Протокол діалогу SSL містить 2 основні фази.

Перша фаза використовується для встановлення конфіденційного каналу комунікацій.

Ця фаза ініціалізує з'єднання, коли обидва партнери обмінюються повідомленнями "hello". Клієнт посилає повідомлення CLIENT-HELLO. Сервер отримує це повідомлення, обробляє його і посилає у відповідь повідомлення SERVER-HELLO.

У цей момент і сервер і клієнт мають достатньо інформації, щоб знати, чи потрібен новий master key. Якщо ключ не потрібен, сервер і клієнт переходять у фазу 2.

Коли виникає необхідність створення нового master key, повідомлення сервера SERVERHELLO вже містить достатньо даних для того, щоб клієнт міг згенерувати master key. У ці дані входять підписаний сертифікат сервера, список базових шифрів і ідентифікатор з'єднання (випадкове число, сгенерированное сервером, яке використовується протягом всієї сесії). Після генерації клієнтом master key він посилає серверу повідомлення CLIENT-MASTER-KEY або ж повідомлення про помилку, коли клієнт і сервер не можуть узгодити базовий шифр.

Після визначення master key сервер посилає клієнтові повідомлення SERVER-VERIFY, що аутентифікує сервер.

Фаза 2 називається фазою аутентифікації. Т. к. Сервер вже аутентифікований на першій фазі, то на другій фазі здійснюється аутентифікація клієнта. Сервер відправляє запит клієнта і, якщо у клієнта є необхідна інформація, він надсилає позитивний відгук, якщо ж ні, то повідомлення про помилку. Коли один партнер виконав аутентифікацію іншого партнера, він посилає повідомлення finished. У разі клієнта повідомлення CLIENTFINISHED містить зашифровану форму ідентифікатора CONNECTION-ID, яку повинен верифікувати сервер. Якщо верифікація була невдалою, сервер посилає повідомлення ERROR.

Коли один з партнерів послав повідомлення finished він повинен приймати повідомлення до тих пір, поки не отримає повідомлення finished від іншого партнера, і тільки коли обидва партнери послали і отримали повідомлення finished протокол діалогу SSL закінчить свою роботу. З цього моменту починає роботу прикладної протокол.

## Протокол TLS

TLS (Transport Layer Security) - кріптографічний протокол, що забезпечує захищену передачу даних між вузлами в мережі Інтернет.

Так як більшість протоколів зв'язку можуть бути використані як з, так і без TLS (або SSL), під час активного з'єднання необхідно явно вказати серверу, чи хоче клієнт встановлювати TLS. Це може бути досягнуто або за допомогою використання уніфікованого номера порту, по якому з'єднання завжди встановлюється з використанням TLS (наприклад, порт 443 для HTTPS), або з використанням довільного порту та спеціальної команди сервера з боку клієнта на перемикання з'єднання на TLS з використанням спеціальних механізмів протоколу (наприклад, STARTTLS для протоколів електронної пошти). Як тільки клієнт і сервер домовилися про використання TLS, їм необхідно встановити захищене з'єднання. Це робиться за допомогою процедури підтвердження зв'язку. Під час цього процесу клієнт і сервер приймають угоду щодо різних параметрів, необхідних для установки безпечного з'єднання.

Основні кроки процедури створення захищеного сеансу зв'язку:

1.  Покупець підключається до сервера, що підтримує TLS, і запитує захищене з'єднання;
2.  Покупець надає список підтримуваних алгоритмів шифрування і хешфункцій;
3.  сервер вибирає зі списку, наданого клієнтом, найбільш надійні алгоритми серед тих, які підтримуються сервером, і повідомляє про свій вибір клієнта;
4.  сервер відправляє клієнту цифровий сертифікат для власної аутентифікації. Зазвичай цифровий сертифікат містить ім'я сервера, ім'я засвідчувального центру сертифікації і відкритий ключ сервера;
5.  клієнт може зв'язатися з сервером довіреної центру сертифікації та підтвердити автентичність переданого сертифіката до початку передачі даних;
6.  для генерації сеансового ключа для захищеного з'єднання клієнт шифрує випадково згенерувала цифрову послідовність відкритим ключем сервера і посилає результат на сервер. З огляду на специфіку алгоритму асиметричного шифрування, що використовується для встановлення з'єднання, тільки сервер може розшифрувати отриману послідовність, використовуючи свій закритий ключ.

На цьому закінчується процедура підтвердження зв'язку. Між клієнтом і сервером встановлено безпечне з'єднання, дані, що передаються по ньому, шифруються і розшифровуються за використанням ключа шифрування до тих пір, поки з'єднання не буде завершено.

При виникненні помилки на будь-якому з вищевказаних кроків підтвердження зв'язку завершиться з помилкою і з'єднання не буде встановлено.

Заходи безпеки в TLS:

*   Захист від зниження версії протоколу до попередньої (менш захищеною) версії або менш надійного алгоритму шифрування;
*   Нумерація послідовних записів додатки і використання порядкового номера в коді аутентифікації повідомлення (MAC);
*   Використання ключа в ідентифікатор повідомлення (тільки власник ключа може перевірити код аутентифікації повідомлення). Хеш-код ідентифікації повідомлень (HMAC), який використовується в більшості шифрів з набору шифрів TLS, був визначений в RFC 2104;
*   Повідомлення, яким закінчується підтвердження зв'язку ( «Finished»), містить в собі хеш всіх повідомлень, якими обмінялися сторони в процесі підтвердження зв'язку;
*   Псевдослучайная функція розбиває вхідні дані на дві частини і обробляє кожну різної хеш-функцією (MD5 і SHA-1), а потім обчислює XOR від двох отриманих згорток, щоб створити код аутентифікації повідомлення. Це забезпечує безпеку навіть у разі уразливості однією з хеш-функцій.

Процедура підтвердження зв'язку в TLS в деталях

Згідно з протоколом TLS додатки обмінюються записами, інкапсулює (зберігають всередині себе) інформацію, яка повинна бути передана. Кожна із записів може бути стиснута, доповнена, зашифрована або ідентифікована MAC (код аутентифікації повідомлення) в залежності від поточного стану з'єднання (стану протоколу). Кожен запис в TLS містить наступні поля: content type (визначає тип вмісту записи), поле, яке вказує довжину пакета, і поле, яке вказує версію протоколу TLS.

Коли з'єднання тільки встановлюється, взаємодія йде по протоколу TLS handshake, content type якого 22.

Просте підтвердження зв'язку в TLS

Далі показаний простий приклад встановлення з'єднання, при якому сервер (але не клієнт) проходить аутентифікацію по його сертифікату.

1. Фаза переговорів:
*   Клієнт посилає повідомлення ClientHello, вказуючи останню версію підтримуваного TLS протоколу, випадкове число і список підтримуваних методів шифрування і стиснення, придатних для роботи з TLS;
*   Сервер відповідає повідомленням ServerHello, що містить: обрану сервером версію протоколу, випадкове число, надіслане клієнтом, відповідний алгоритм шифрування і стиснення зі списку наданого клієнтом;
*   Сервер посилає повідомлення Certificate, яке містить цифровий сертифікат сервера (в залежності від алгоритму шифрування цей етап може бути пропущений);
*   Сервер відсилає повідомлення ServerHelloDone, що ідентифікує закінчення підтвердження зв'язку;
*   Клієнт відповідає повідомленням ClientKeyExchange, яке містить відкритий ключ PreMasterSecret (Цей PreMasterSecret шифрується за допомогою відкритого ключа сертифіката сервера) або нічого (знову ж таки залежить від алгоритму шифрування);
*   Клієнт і сервер, використовуючи ключ PreMasterSecret і випадково згенеровані числа, обчислюють загальний секретний ключ. Вся інша інформація про ключі буде отримана із загального секретного ключа (і згенерованих клієнтом і сервером випадкових значень);

2. Клієнт посилає повідомлення ChangeCipherSpec, яке вказує на те, що вся подальша інформація буде зашифрована встановленим в процесі підтвердження зв'язку алгоритмом, використовуючи загальний секретний ключ. Це повідомлення рівня записів і тому має тип 20, а не 22;
*   Клієнт посилає повідомлення Finished, яке містить хеш і MAC, згенеровані на основі попередніх повідомлень процедури підтвердження зв'язку;
*   Сервер намагається розшифрувати Finished-повідомлення клієнта і перевірити хеш і МАС.

Якщо процес розшифровки або перевірки не вдається, підтвердження зв'язку вважається невдалим, і з'єднання повинно бути обірвано;

3. Сервер посилає ChangeCipherSpec і зашифроване повідомлення Finished, і в свою чергу клієнт теж виконує розшифровку і перевірку.

З цього моменту підтвердження зв'язку вважається завершеним, протокол встановленим. Все подальше вміст пакетів йде з типом 23, а всі дані будуть зашифровані.

## Відновлення TLS-з'єднання


Алгоритми асиметричного шифрування, що використовуються при генерації сеансового ключа, зазвичай є дорогими з точки зору обчислювальних потужностей. Для того щоб уникнути їх повторення при відновленні з'єднання, TLS створює спеціальний ярлик при підтвердженні зв'язку, що використовується для відновлення з'єднання. При цьому при звичайному підтвердження зв'язку клієнт додає в повідомлення ClientHello ідентифікатор попередньої сесії session id. Клієнт пов'язує ідентифікатор session id з IP-адресою сервера і TCP-портом так, щоб при з'єднанні з сервером можна було використовувати всі параметри попереднього з'єднання. Сервер зіставляє ідентифікатор попередньої сесії session id c параметрами з'єднання, такими як використаний алгоритм шифрування і master secret. Обидві сторони повинні мати однаковий master secret, інакше з'єднання не буде встановлено. Це запобігає використанню session id криптоаналітиків для отримання несанкцианированного доступу. Випадкові цифрові послідовності в повідомленнях ClientHello і ServerHello дозволяють гарантувати, що згенерований сеансовий ключ буде відрізнятися від сеансового ключа при попередньому з'єднанні. В RFC такий тип підтвердження зв'язку називається скороченим.

1. Фаза переговорів:

*   Клієнт посилає повідомлення ClientHello, вказуючи останню версію підтримуваного TLS протоколу, випадкове число і список підтримуваних методів шифрування і стиснення, придатних для роботи з TLS; Також в повідомлення додається ідентифікатор попереднього з'єднання session id.
*   Сервер відповідає повідомленням ServerHello, що містить: обрану сервером версію протоколу, випадкове число, надіслане клієнтом, відповідний алгоритм шифрування і стиснення зі списку наданого клієнтом. Якщо сервер дізнався ідентифікатор сесії session id, то він додає в повідомлення ServerHello той же самий ідентифікатор session id. Це є сигналом для клієнта про те, що можна використовувати відновлення попередньої сесії. Якщо сервер не впізнав ідентифікатор сесії session id, то він додає в повідомлення ServerHelloдругое значення замість session id. Для клієнта це означає, що використовувати відновлену з'єднання не можна. Таким чином, сервер і клієнт повинні мати однаковий master secret і випадкові числа для генерації сеансового ключа;

2. Сервер посилає повідомлення ChangeCipherSpec, яке вказує на те, що вся подальша інформація буде зашифрована встановленим в процесі підтвердження зв'язку алгоритмом, використовуючи загальний секретний ключ. Це повідомлення рівня записів і тому має тип 20, а не 22;

*   Сервер посилає зашифроване повідомлення Finished, яке містить хеш і MAC, згенеровані на основі попередніх повідомлень процедури підтвердження зв'язку;
*   Клієнт намагається розшифрувати Finished повідомлення сервера і перевірити хеш і МАС. Якщо процес розшифровки або перевірки не вдається, підтвердження зв'язку вважається невдалим, і з'єднання повинно бути обірвано;

3. Клієнт посилає повідомлення ChangeCipherSpec, яке вказує на те, що вся подальша інформація буде зашифрована встановленим в процесі підтвердження зв'язку алгоритмом, використовуючи загальний секретний ключ.

*   Клієнт посилає своє зашифроване повідомлення Finished;
*   Сервер схожим чином намагається розшифрувати Finished повідомлення клієнта і перевірити хеш і MAC;

З цього моменту підтвердження зв'язку вважається завершеним, протокол встановленим. Все подальше вміст пакетів йде з типом 23, а всі дані будуть зашифровані.

Крім переваг з точки зору продуктивності, алгоритм відновлення з'єднання може бути використаний для реалізації єдиного входу, оскільки гарантується, що вихідною сесія, як і будь-яка Відновлена сесія, ініційована тим же самим клієнтом (RFC 5077). Це має особливо важливе значення для реалізації FTPS протоколу, який в іншому випадку був би вразливий до атаки типу людина посередині, при якій зловмисник міг би перехопити зміст даних при встановленні повторного з'єднання.

## Мандати сесій


RFC 5077 розширює TLS через використання мандатів сесій (session tickets), замість ідентифікаторів з'єднань (session id). Він визначає спосіб відновлення сеансу TLS, не вимагаючи session id прідидущей сесії, стан якої зберігається на TLS сервері.

При використанні сесійних мандатів, TLS сервер зберігає сеансовое стан в мандаті сеансу і посилає його для зберігання на TLS клієнта. Клієнт відновлює TLS сесію відправивши мандат сеансу на сервер, а сервер відновлює TLS сесію відповідно до параметрів конкретної сесії, збереженими в прийнятому мандат. Сесійна мандат шифрується, в зашифрованому вигляді проходить аутентифікацію на сервері, і сервер перевіряє його обгрунтованість перш ніж використовувати вміст мандата.

Одна з слабкостей цього методу - для шифрування і аутентифікації переданих сесійних мандатів завжди доступне лише AES128-CBC-SHA256, незалежно від того, які параметри TLS обрані і використовуються для самого TLS з'єднання. Це означає, щоі нформація про TLS сесії (що зберігається в сесійній мандат) не так добре захищена, як в рамках самої TLS сесії.

### Алгоритми, що використовуються в TLS

*   Для обміну ключами і перевірки їх достовірності застосовуються комбінації алгоритмів: RSA (асиметричний шифр), Diffie-Hellman (безпечний обмін ключами), DSA (алгоритм цифрового підпису), ECDSA;
*   Для симетричного шифрування: RC4, IDEA, Triple DES, SEED, Camellia або AES;
*   Для хеш-функцій: MD5, SHA, SHA-256/384.

## Теми для самостійного вивчення


1.  Історія появи та розвитку SSL
2.  Механізм роботи SSL
3.  Механізм роботи TLS
4.  Надійні та ненадійні сертифікати SSL
5.  Методи втручання в роботу захищеного з'єднання HTTPS

## Контрольні питання


1.  Яке призначення протоколу HTTPS?
2.  На базі яких протоколів формується SSL-з'єднання?
3.  На базі яких протоколів формується TLS-з'єднання?
4.  На чому базується протокол HTTPS?
5.  Який порт веб-сервера обслуговує з'єднання HTTPS за замовчуванням?