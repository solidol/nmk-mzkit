# Функції

Найчастіше нам треба повторювати одне і те ж дію в багатьох частинах програми.

Наприклад, необхідно красиво вивести повідомлення при вітанні відвідувача, при виході відвідувача з сайту, ще де-небудь.

Щоб не повторювати один і той же код в багатьох місцях, придумані функції. Функції є основними «будівельними блоками» програми.

Приклади вбудованих функцій ви вже бачили - це `alert (message)`, ` prompt (message, default)` і `confirm (question)`. Але можна створювати і свої.

## Оголошення функції

Для створення функцій ми можемо використовувати  оголошення функції.

Приклад оголошення функції:

```
function showMessage () {
  alert ( 'Всім привіт!');
}
```

Спочатку йде ключове слово `function`, після нього ім'я функції, потім список параметрів в круглих дужках через кому (у вищенаведеному прикладі він порожній) і, нарешті, код функції, також званий" тілом функції ", всередині фігурних дужок.

```
function ім'я (параметри) {
  ... тіло ...
}
```

Наша нова функція може бути викликана за її імені: `showMessage()`.

наприклад:

```
function showMessage () {
  alert ( 'Всім привіт!');
}

*! *
showMessage ();
showMessage ();
* /! *
```

Виклик `showMessage()` виконує код функції. Тут ми побачимо повідомлення двічі.

Цей приклад явно демонструє одне з головних призначень функцій: позбавлення від дублювання коду.

Якщо знадобиться поміняти повідомлення або спосіб його виведення - досить змінити його в одному місці: в функції, яка його виводить.

## Локальні змінні

Змінні, оголошені всередині функції, видно тільки всередині цієї функції.

наприклад:

```
function showMessage () {
*! *
  let message = "Привіт, я JavaScript!"; // локальна змінна
* /! *

  alert (message);
}

showMessage (); // Привіт, я JavaScript!

alert (message); // <- буде помилка, тому що змінна видно тільки всередині функції
```

## Зовнішні змінні

У функції є доступ до зовнішніх змінним, наприклад:

```
let *! * userName * /! * = 'Вася';

function showMessage () {
  let message = 'Привіт,' + *! * userName * /! *;
  alert (message);
}

showMessage (); // Привіт Василь
```

Функція має повний доступом до зовнішніх змінним і може змінювати їх значення.

наприклад:

```
let *! * userName * /! * = 'Вася';

function showMessage () {
  *! * UserName * /! * = "Петя"; // (1) змінюємо значення зовнішньої змінної

  let message = 'Привіт,' + *! * userName * /! *;
  alert (message);
}

alert (userName); // *! * Вася * /! * Перед викликом функції

showMessage ();

alert (userName); // *! * Петя * /! *, Значення зовнішньої змінної було змінено функцією
```

Зовнішня змінна використовується, тільки якщо всередині функції немає такої локальної.

Якщо однойменна змінна оголошується всередині функції, тоді вона перекриває зовнішню. Наприклад, в коді нижче функція використовує локальну змінну `userName`. Зовнішня буде проігнорована:

```
let userName = 'Вася';

function showMessage () {
*! *
  let userName = "Петя"; // оголошуємо локальну змінну
* /! *

  let message = 'Привіт,' + userName; // *! * Петя * /! *
  alert (message);
}

// функція створить і буде використовувати свою власну локальну змінну userName
showMessage ();

alert (userName); // *! * Вася * /! *, Не змінилася, функція не чіпала зовнішню змінну
```


Змінні, оголошені зовні всіх функцій, такі як зовнішня змінна `userName` у вищенаведеному коді - називаються глобальними.

Глобальні змінні видимі для будь-якої функції (якщо тільки їх не перекривають однойменні локальні змінні).

Бажано зводити використання глобальних змінних до мінімуму. У сучасному коді зазвичай мало або зовсім немає глобальних змінних. Хоча вони іноді корисні для зберігання найважливіших "общепроектових" даних.



## Параметри

Ми можемо передати всередину функції будь-яку інформацію, використовуючи параметри (також звані  аргументами функції ).

У нижчеподаному прикладі функції передаються два параметри: `from` і `text`.

```
function showMessage (*! * from, text * /! *) {// аргументи: from, text
  alert (from + ':' + text);
}

*! *
showMessage ( 'Аня', 'Привіт!'); // Аня: Привіт! (*)
showMessage ( 'Аня', "Як справи?"); // Аня: Як справи? (**)
* /! *
```

Коли функція викликається в рядках `(*)` і `(**)`, передані значення копіюються в локальні змінні `from` і` text`. Потім вони використовуються в тілі функції.

Ось ще один приклад: у нас є змінна `from`, і ми передаємо її функції. Зверніть увагу: функція змінює значення `from`, але ця зміна не видно зовні. Функція завжди отримує тільки копію значення:


```
function showMessage (from, text) {

*! *
  from = '*' + from + '*'; // трохи прикрасимо "from"
* /! *

  alert (from + ':' + text);
}

let from = "Аня";

showMessage (from, "Привіт"); // * Аня *: Привіт

// значення "from" залишилося колишнім, функція змінила значення локальної змінної
alert (from); // Аня
```

## Параметри за замовчуванням

Якщо параметр не вказано, то його значенням стає `undefined`.

Наприклад, вищезгадана функція `showMessage (from, text)` може бути викликана з одним аргументом:

```
showMessage ( "Аня");
```

Це не призведе до помилки. Такий виклик виведе `"Аня: undefined"`. У виклику не вказано параметр `text`, тому передбачається, що` text === undefined`.

Якщо ми хочемо задати параметру `text` значення за замовчуванням, ми повинні вказати його після` = `:

```
function showMessage (from, *! * text = "текст не додано" * /! *) {
  alert (from + ":" + text);
}

showMessage ( "Аня"); // Аня: текст не доданий
```

Тепер, якщо параметр `text` не вказано, його значенням буде `"текст не додано"`

В даному випадку `" текст не додано "` це рядок, але на її місці могло б бути і більш складне вираз, яке б обчислювалося і присвоювалося при відсутності параметра. наприклад:

```
function showMessage (from, text = anotherFunction ()) {
  // anotherFunction () виконається тільки якщо не переданий text
  // результатом буде значення text
}
```


В JavaScript параметри за замовчуванням обчислюються кожен раз, коли функція викликається без відповідного параметра.

В наведеному вище прикладі `anotherFunction ()` буде викликатися кожен раз, коли `showMessage ()` викликається без параметра `text`.


Ранні версії JavaScript не підтримували параметри за замовчуванням. Тому існують альтернативні способи, які можуть зустрічатися в старих скриптах.

Наприклад, явна перевірка на `undefined`:

```
function showMessage (from, text) {
*! *
  if (text === undefined) {
    text = 'текст не доданий';
  }
* /! *

  alert (from + ":" + text);
}
```

... Або за допомогою оператора `||`:

```
function showMessage (from, text) {
  // Якщо значення text помилково, тоді привласнити параметру text значення за замовчуванням
  text = text || 'Текст не доданий';
  ...
}
```

## Повернення значення

Функція може повернути результат, який буде переданий в який викликав її код.

Найпростішим прикладом може служити функція складання двох чисел:

```
function sum (a, b) {
  *! * Return * /! * A + b;
}

let result = sum (1, 2);
alert (result); // 3
```

Директива `return` може перебувати в будь-якому місці тіла функції. Як тільки виконання доходить до цього місця, функція зупиняється, і значення повертається в який викликав її код (присвоюється змінної `result` вище).

Викликів `return` може бути кілька, наприклад:

```
function checkAge (age) {
  if (age> 18) {
*! *
    return true;
* /! *
  } Else {
*! *
    return confirm ( 'А батьки дозволили?');
* /! *
  }
}

let age = prompt ( 'Скільки вам років?', 18);

if (checkAge (age)) {
  alert ( 'Доступ отриманий');
} Else {
  alert ( 'доступі');
}
```

Можливо використовувати `return` і без значення. Це призведе до негайного виходу з функції.

наприклад:

```
function showMovie (age) {
  if (! checkAge (age)) {
*! *
    return;
* /! *
  }

  alert ( "Вам показується кіно"); // (*)
  // ...
}
```

У коді вище, якщо `checkAge (age)` поверне `false`,` showMovie` не виконає `alert`.


Якщо функція не повертає значення, це все одно, як якщо б вона повертала `undefined`:

```
function doNothing () {/ * порожньо * /}

alert (doNothing () === undefined); // true
```

Порожній `return` аналогічний` return undefined`:

```
function doNothing () {
  return;
}

alert (doNothing () === undefined); // true
```



Для довгого вираження в `return` може бути заманливо розмістити його на кількох окремих рядках, наприклад так:

```
return
 (Some + long + expression + or + whatever * f (a) + f (b))
```
Код не виконається, тому що інтерпретатор JavaScript підставить крапку з комою після `return`. Для нього це буде виглядати так:

```
return *! *; * /! *
 (Some + long + expression + or + whatever * f (a) + f (b))
```

Таким чином, це фактично стало порожнім `return`.

Якщо ми хочемо, щоб повертається вираз займало кілька рядків, потрібно почати його на тому ж рядку, що і `return`. Або, хоча б, поставити там відкриває дужку, ось так:

```
return (
  some + long + expression
  + Or +
  whatever * f (a) + f (b)
  )
```

І тоді все спрацює, як задумано.


## Вибір імені функції [# function-naming]

Функція - це дія. Тому ім'я функції зазвичай є дієсловом. Воно повинно бути простим, точним і описувати дію функції, щоб програміст, який буде читати код, отримав вірне уявлення про те, що робить функція.

Як правило, використовуються дієслівні префікси, що позначають загальний характер дії, після яких слід уточнення. Зазвичай в командах розробників діють угоди, що стосуються значень цих префіксів.

Наприклад, функції, що починаються з `" show "` зазвичай щось показують.

Функції, що починаються з ...

- `" get ... "` - повертають значення,
- `" calc ... "` - щось обчислюють,
- `" create ... "` - щось створюють,
- `" check ... "` - щось перевіряють і повертають логічне значення, і т.д.

Приклади таких імен:

```
showMessage (..) // показує повідомлення
getAge (..) // повертає вік (в будь-якому значенні)
calcSum (..) // обчислює суму і повертає результат
createForm (..) // створює форму (і зазвичай повертає її)
checkPermission (..) // перевіряє доступ, повертаючи true / false
```

Завдяки префіксам, при першому погляді на ім'я функції стає зрозумілим що робить її код, і яке значення вона може повертати.


Функція повинна робити тільки те, що явно мається на увазі її назвою. І це повинно бути одним дією.

Два незалежних дії зазвичай мають на увазі дві функції, навіть якщо передбачається, що вони будуть викликатися разом (в цьому випадку ми можемо створити третю функцію, яка буде їх викликати).

Кілька прикладів, які порушують це правило:

- `getAge` - буде поганим вибором, якщо функція буде виводити` alert` з віком (повинна тільки повертати його).
- `createForm` - буде поганим вибором, якщо функція буде змінювати документ, додаючи форму в нього (має тільки створювати форму і повертати її).
- `checkPermission` - буде поганим вибором, якщо функція буде відображати повідомлення з текстом` доступ дозволений / запрещён` (повинна тільки виконувати перевірку і повертати її результат).

У цих прикладах використовувалися загальноприйняті смисли префіксів. Звичайно, ви в команді можете домовитися про інші значеннях, але зазвичай вони мало відрізняються від загальноприйнятих. У будь-якому випадку ви і ваша команда повинні точно розуміти, що означає префікс, що функція з ним може робити, а чого не може.


Імена функцій, які використовуються дуже часто, іноді роблять надкоротких. В основному імена функцій повинні 

## Функції == Коментарі

Функції повинні бути короткими і робити тільки щось одне. Якщо це щось велике, має сенс розбити функцію на кілька менших. Іноді дотримуватися цього правила непросто, але це безперечно гарне правило.

Невеликі функції не тільки полегшують тестування і налагодження - саме існування таких функцій виконує роль хороших коментарів!

Наприклад, порівняємо нижче дві функції `showPrimes (n)`. Кожна з них виводить [просте число]  до `n`.

Перший варіант використовує мітку `nextPrime`:

```
function showPrimes (n) {
  nextPrime: for (let i = 2; i <n; i ++) {

    for (let j = 2; j < i; j ++) {
      if (i% j == 0) continue nextPrime;
    }

    alert (i); // просте
  }
}
```

Другий варіант використовує додаткову функцію `isPrime (n)` для перевірки на просте:

```
function showPrimes (n) {

  for (let i = 2; i <n; i ++) {
    *! * If (! IsPrime (i)) continue; * /! *

    alert (i); // просте
  }
}

function isPrime (n) {
  for (let i = 2; i <n; i ++) {
    if (n% i == 0) return false;
  }
  return true;
}
```

Другий варіант легше для розуміння, чи не так? Замість шматка коду ми бачимо назву дії ( `isPrime`). Іноді розробники називають такий код самодокументіруемим.

Таким чином, допустимо створювати функції, навіть якщо ми не плануємо повторно використовувати їх. Такі функції структурують код і роблять його більш зрозумілим.


## Підсумок

Оголошення функції має вигляд:

```
function ім'я (параметри, через, кому) {
  / * Тіло, код функції * /
}
```

- Передані значення копіюються в параметри функції і стають локальними змінними.
- Функції мають доступ до зовнішніх змінним. Але це працює тільки зсередини назовні. Код поза функції не має доступу до її локальних змінних.
- Функція може повертати значення. Якщо цього не відбувається, тоді результат дорівнює `undefined`.

Для того, щоб зробити код більш чистим і зрозумілим, рекомендується використовувати локальні змінні і параметри функцій, не користуватися зовнішніми змінними.

Функція, яка отримує параметри, працює з ними і потім повертає результат, набагато зрозуміліше функції, що викликається без параметрів, але змінює зовнішні змінні, що загрожує побічними ефектами.

Іменування функцій:

- Ім'я функції має зрозуміло і чітко відображати, що вона робить. Побачивши її виклик в коді, ви повинні тут же розуміти, що вона робить, і що повертає.
- Функція - це дія, тому її ім'я зазвичай є дієсловом.
- Є багато загальноприйнятих префіксів, таких як: `create ...`, `show ...`, `get ...`, `check ...` і т.д. Користуйтеся ними як підказками, що пояснюють, що робить функція.

Функції є основними будівельними блоками скриптів. Ми розглянули лише основи функцій в JavaScript, але вже зараз можемо створювати і використовувати їх. Це тільки початок шляху. Ми будемо неодноразово повертатися до функцій і вивчати їх все більше і більше глибоко.