# Структура HTML-документа і елементи розмітки заголовка документа

[Перелік усіх лекцій](README.md)

## Протокол HTTP

HyperText Transfer Protocol - протокол передачі гіпертексту. Використовується службою WWW для передачі Web-сторінок.

Tранспортним протоколом для HTTP є протокол TCP, причому сервер HTTP (сервер Web) знаходиться в стані очікування з'єднання з боку клієнта стандартно по порту 80 TCP, а клієнт HTTP (браузер Web) є ініціатором з'єднання.

Основним об'єктом маніпуляції в HTTP є ресурс, на який вказує URI (Uniform Resource Identifier) в запиті клієнта. У найзагальнішому випадку URI виглядає наступним чином:

`protocol://user:password@host:port/path/file?parameters#fragment`

Окремі поля URI мають наступний сенс:

*   protocol - прикладний протокол, за допомогою якого отримують доступ до ресурсу;
*   user - користувач, від імені якого отримують доступ до ресурсу;
*   password - пароль користувача для аутентифікації при доступі до ресурсу;
*   host - IP-адреса або ім'я сервера, на якому розташований ресурс;
*   port - номер порту, на якому працює сервер, що надає доступ до ресурсу;
*   path - шлях до файлу, який містить ресурс;
*   file - файл, що містить ресурс;
*   parameters - параметри для обробки ресурсом-програмою;
*   fragment - точка в файлі, починаючи з якої слід відображати ресурс.

## HTTP-запити

Взаємодія між клієнтом і сервером Web здійснюється шляхом обміну повідомленнями. Повідомлення HTTP діляться на запити клієнта серверу і відповіді сервера клієнтові. HTTP не зберігає свого стану. Це означає відсутність збереження проміжного стану між парами «запит-відповідь». Компоненти, що використовують HTTP, можуть самостійно здійснювати збереження інформації про стан, пов'язаної з останніми запитами і відповідями (наприклад, «куки» на стороні клієнта, «сесії» на стороні сервера). Браузер, який посилає запити, може відстежувати затримки відповідей. Сервер може зберігати IP-адреси і заголовки запитів останніх клієнтів. Однак сам протоколу не обізнаний про попередні запити і відповідях, в ньому не передбачена внутрішня підтримка стану, до нього не пред'являються такі вимоги.

Запити та відповіді виглядають наступним чином:
> початковий рядок 
> заголовок 1 
> заголовок 2 ...
> заголовок N
> CR LF (порожній рядок) 
> тіло повідомлення (може бути відсутнім)

Формат початкового рядка (start-line) клієнта і сервера розрізняються. Заголовки бувають чотирьох видів:

*   загальні заголовки (general-headers), які можуть бути присутніми як в запиті, так і у відповіді;
*   заголовки запитів (request-headers), які можуть бути присутніми тільки в запиті;
*   заголовки відповідей (response-headers), які можуть бути присутніми тільки у відповіді;
*   заголовки об'єкта (entity-headers), які відносяться до тіла повідомлення і описують його вміст.

Кожен заголовок складається з назви, символу двокрапки ":" і значення.

У тексті листа міститься власне передана інформація. Тіло повідомлення являє собою послідовність октетів (байтів). Тіло повідомлення може бути закодовано, наприклад, для зменшення обсягу переданої інформації, при цьому спосіб кодування вказується в заголовку об'єкта Content-Encoding.

Запит від клієнта до сервера складається з рядка запиту (request-line), заголовків (загальних, запитів, об'єкта) і, можливо, тіла повідомлення.

Рядок запиту:

`<Метод HTTP> <Ідентифікатор запитуваного ресурсу> <Версія HTTP>`

Метод HTTP (або команда) - послідовність з будь-яких символів, крім керуючих і роздільників, яка вказує на основну операцію над ресурсом. Зазвичай являє собою короткий англійське слово, записане великими літерами. Назва методу чутливе до регістру.

Кожен сервер зобов'язаний підтримувати як мінімум методи GET і HEAD. Якщо сервер не розпізнав вказаний клієнтом метод, то він повинен повернути статус 501 (Not Implemented). Якщо серверу метод відомий, але він непридатний до конкретного ресурсу, то повертається повідомлення з кодом 405 (Method Not Allowed). В обох випадках в повідомлення відповіді включається заголовок Allow зі списком підтримуваних методів.

### Методи HTTP-запитиів

#### OPTIONS

Використовується для визначення можливостей веб-сервера або параметрів з'єднання для конкретного ресурсу. У відповідь - заголовок Allow зі списком підтримуваних методів. Також може включатися інформація про підтримуваних розширеннях.

Для того, щоб дізнатися можливості всього сервера, клієнт повинен вказати в URI зірочку - «\*». Запити «OPTIONS \* HTTP / 1.1» можуть також застосовуватися для перевірки працездатності сервера (аналогічно «пингования») і тестування на предмет підтримки сервером протоколу HTTP версії 1.1. Результат виконання методу не кешируєтся.

#### GET

Використовується для запиту вмісту зазначеного ресурсу. За допомогою методу GET можна також почати будь-який процес. можна передавать параметри виконання запиту в URI цільового ресурсу після символу «?»:

`GET /path/resource?Param1=value1¶m2=value2 HTTP / 1.1`

Метод є ідемпотентним: на однаковий GET - однаковий результат.

#### HEAD

Аналогічний GET, за винятком того, що у відповіді сервера відсутнє тіло. Запит HEAD зазвичай застосовується для вилучення метаданих, перевірки наявності ресурсу (валідація URL) і щоб дізнатися, чи не змінився він з моменту останнього звернення.

#### POST

Застосовується для передачі призначених для користувача даних заданому ресурсу. Аналогічно за допомогою методу POST зазвичай завантажуються файли на сервер.

На відміну від методу GET, метод POST не рахується ідемпотентна - багаторазове повторення одних і тих же запитів POST може повертати різні результати.

#### PUT

Застосовується для завантаження вмісту запиту на вказаний в запиті URI.

Фундаментальна відмінність методів POST і PUT полягає в розумінні призначень URI ресурсів. Метод POST передбачає, що за вказаною URI буде проводитися обробка переданого клієнтом вмісту. Використовуючи PUT, клієнт передбачає, що завантажувати вміст відповідає що знаходиться за даним URI ресурсу.

#### PATCH

PATCH Аналогічно PUT, але застосовується тільки до фрагменту ресурсу.

#### DELETE

DELETE Видаляє зазначений ресурс.

#### TRACE

Повертає отриманий запит так, що клієнт може побачити, яку інформацію проміжні сервери додають або змінюють в запиті.

#### CONNECT

Перетворює з'єднання запиту в прозорий TCP / IP тунель, зазвичай щоб сприяти встановленню захищеного SSL з'єднання через нешифрований проксі.

### Відповідь сервера клієнту

`<Версія HTTP> <Код стану> <Пояснююча фраза>`

Код стану (Status-Code) - це цілочисельний трьохрозрядний код результату розуміння і задоволення запиту. Яка пояснює фраза (Reason-Phrase) - короткий текстовий опис коду стану. Код стану призначений для обробки програмним забезпеченням, а яка пояснює фраза призначена для користувачів.

Перша цифра коду стану визначає клас відповіді. Останні дві цифри не мають певної ролі в класифікації. Є 5 значень першої цифри:

*   1xx: Інформаційні коди - запит отримано, триває обробка.
*   2xx: Успішні коди - дія була успішно отримано, зрозуміле і оброблено.
*   3xx: Коди перенаправлення - для виконання запиту повинні бути зроблені подальші дії.
*   4xx: Коди помилок клієнта - запит має помилку синтаксису або не може бути виконаний.
*   5xx: Коди помилок сервера - сервер не в змозі виконати допустимий запит.

Хоча протокол HTTP розроблявся як засіб роботи з ресурсами сервера, у нього відсутні в явному вигляді засоби навігації серед цих ресурсів. Наприклад, клієнт не може явно запросити список доступних файлів, як в протоколі FTP. Передбачалося, що кінцевий користувач уже знає URI необхідного йому документа, закачавши який, він буде робити навігацію завдяки гіперпосиланням. Це цілком нормально і зручно для людини, але важко, коли стоять задачі автоматичної обробки і аналізу всіх ресурсів сервера без участі людини. Вирішення цієї проблеми лежить повністю на плечах розробників додатків, що використовують даний протокол.

Більшість протоколів передбачають встановлення TCP-сесії, в ході якої один раз відбувається авторизація, і подальші дії виконуються в контексті цієї авторизації. HTTP же встановлює окрему TCP-сесію на кожен запит; в більш пізніх версіях HTTP було дозволено робити кілька запитів в ході однієї TCP-сесії, але браузери зазвичай запитують тільки сторінку і включені в неї об'єкти (картинки, каскадні таблиці стилів і т. п.), а потім відразу розривають TCP-сесію. Для підтримки авторизованого (неанонімного) доступу в HTTP використовуються cookies; причому такий спосіб авторизації дозволяє зберегти сесію навіть після перезавантаження клієнта і сервера.

При доступі до даних по FTP або по файловим протоколам тип файлу (точніше, тип містяться в ньому даних) визначається по розширенню імені файлу, що не завжди зручно. HTTP перед тим, як передати самі дані, передає заголовок «Content-Type: тип / підтип», що дозволяє клієнту однозначно визначити, яким чином обробляти надіслані дані. Це особливо важливо при роботі з CGI-скриптами, коли розширення імені файлу вказує не на тип присилаються клієнту даних, а на необхідність запуску даного файлу на сервері і відправки клієнтові результатів роботи програми, записаної в цьому файлі (при цьому один і той же файл в залежно від аргументів запиту і своїх власних міркувань може породжувати відповіді різних типів - в найпростішому випадку картинки в різних форматах).

Крім того, HTTP дозволяє клієнтові надіслати на сервер параметри, які будуть передані запускається CGI-скрипту. Для цього ж в HTML були введені форми.

## ОСНОВИ HTML

**HTML (HyperText Markup Language)** - мова гіпертекстової розмітки, що задає розташування елементів на веб-сторінці.Перегляд HTML-документу здійснюється за допомогою браузера, який відображає документ на основі початкового коду, що описує структуру HTML-документа.

Результатом інтерпретації HTML-документа браузером є веб-сторінка, яка, на відміну від HTML-документа містить не лише текст, але й зображення, звук, відео, інтерактивні елементи та інше. Процес інтерпретації **(парсинг)** починається перш, ніж веб-сторінка повністю завантажена в браузер. Браузери обробляють HTML-документи послідовно, з самого початку, при цьому обробляючи CSS і співвідносячи таблиці стилів з елементами сторінки.

Основною одиницею мови HTML є тег. За допомогою тегів описується вся структура HTML-документа. Теги оформляються кутовими дужками <ім'я тегу>, між якими прописується ім'я тегу.

Практично всі теги мають **атрибути** (глобальні, що застосовуються для всіх html-елементів, і власні), які вказуються у форматі **параметр = "значення"**. Атрибути дозволяють змінювати властивості елемента, для якого вони задані. Атрибути прописуються в початковому тезі елемента.

Атрибути **class** і **id** застосовні до всіх HTML-елементів. Кожному конкретному елементу можна привласнити кілька значень class і тільки одне значення id. Множинні значення class записуються через пробіл, наприклад, <div class = "nav top">

Значення class і id повинні складатися тільки з букв, цифр, дефісів і нижніх підкреслень і повинні починатися тільки з літер.

Більшість тегів - парні, вони складаються з початкового і кінцевого тегів. Початковий тег показує, де починається елемент, кінцевий - де закінчується. Закриваючий тег утворюється шляхом додавання слешу / перед ім'ям тега: <ім'я тега> ... . Між початковим і кінцевим тегами знаходиться вміст тега - контент.

Одиночні теги не можуть зберігати в собі вмісту безпосередньо, він прописується як значення атрибута, наприклад, тег <input type = "button" value = "Кнопка">

### Структура HTML-документа

HTML слідує правилам, які містяться у файлі оголошення типу документа (Document Type Definition, або DTD). DTD являє собою XML-документ, що визначає, які теги, атрибути та їх значення дійсні для конкретного типу HTML. Для кожної версії HTML є свій DTD.

DOCTYPE відповідає за коректне відображення веб-сторінки браузером. DOCTYPE визначає не тільки версію HTML (наприклад, html), але і відповідний DTD-файл в Інтернеті.

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Home</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <div class="container">
        <!-- comment -->
        <header>
            <h1>Home</h1>
        </header>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="about.html">About</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
        </nav>
        <main>
            <h2>Welcome to my website</h2>
            <p>This is a simple website created using HTML and CSS.</p>
        </main>
        <footer>
            <p>&copy; 2021 My Website</p>
        </footer>
    </div>
</body>

</html>
```	

Елементи, що знаходяться всередині тега **DOM (document object model)** . При цьому елемент є кореневим елементом.

Щоб розібратися у взаємодії елементів веб-сторінки, необхідно розглянути так звані "родинні стосунки" між елементами. Відносини між множинними вкладеними елементами підрозділяються на батьківські, дочірні та сестринські.

**Предок** - елемент, який містить в собі інші елементи. Gредком для всіх елементів є `<html>`. У той же час елемент `<body>` є предком для всіх містяться в ньому тегів: `<h1>`,`<p>`, `<span>`, `<nav>`і т.д.

**Нащадок** - елемент, розташований всередині одного або більше типів елементів. Наприклад, `<body>` є нащадком `<html>`, а елемент `<p>` є нащадком одночасно для `<body>` і `<html>`.

**Батьківський елемент** - елемент, пов'язаний з іншими елементами нижчого рівня, і що знаходиться на дереві вище їх. На рис. 1 `<html>` є батьківським тільки для `<head>` і `<body>`. Тег `<p>` є батьківським тільки для `<span>`.

**Дочірній елемент** - елемент, безпосередньо підлеглий іншому елементу більш високого рівня. На рис. 1 тільки елементи `<h1>`, `<h2>`, `<p>` і `<nav>` є дочірніми по відношенню до `<body>`.

**Сестринський елемент** - елемент, що має загальний батьківський елемент з даним, так звані елементи одного рівня. На рис. 1 `<head>` і `<body>` - елементи одного рівня, так само як і елементи `<h1>`, `<h2>` і `<p>` є між собою сестринськими.

## Базові теги для формування документа HTML

### Елемент `<HTML>`


Є кореневим елементом документа. Всі інші елементи містяться всередині тегів `<html> ... </html>`. Все, що знаходиться за межами тегів, не сприймається браузером як код HTML і ніяк їм не обробляється. Для елемента доступні атрибути manifest і xmlns, а також глобальні атрибути.

### Елемент `<HEAD>`

Розділ `<head> ... </head>` містить технічну інформацію про сторінку: заголовок, опис, ключові слова для пошукових машин, кодування і т.д. Введена в ньому інформація не відображається у вікні браузера, однак він містить велику кількість даних, які вказують браузеру, як слід обробляти сторінку. Для елемента доступні глобальні атрибути.

### Елемент `<TITLE>`

Обов'язковою тегом розділу `<head>` є тег `<title>`. Текст, розміщений всередині цього тегу, відображається у заголовку браузера. Довжина заголовка повинна бути не більше 60 символів, щоб повністю поміститися в заголовку. Текст заголовка повинен містити максимально повний опис вмісту сторінки. Для елемента доступні глобальні атрибути.

### Елемент `<META>`

Необов'язковим тегом розділу `<head>` є одинарний тег `<meta>`. З його допомогою можна задати опис вмісту сторінки і ключові слова для пошукових машин, автора html-документа та інші властивості метаданих. Елемент `<head>` може містити кілька елементів `<meta>`, бо в залежності від використаних атрибутів вони несуть різну інформацію. Для елемента `<meta>` доступні атрибути charset, content, http-equiv, name, а також глобальні атрибути.

### Елемент `<LINK>`

Елемент не вимагає закриваючого тегу. Даний елемент визначає відносини між поточною сторінкою та іншими документами. Таких елементів на сторінці може бути кілька. Запис буде мати наступний вигляд: `<link rel = "stylesheet" href = "style.css" type = "text/css">`

Для елемента доступні атрибути `href`, `hreflang`, `media`, `rel`, `type`, `а` також глобальні атрибути.

### Елемент `<STYLE>`

Всередині цього елемента задаються стилі, які використовуються на сторінці. Для завдання стилів в html-документі використовується мова CSS. Таких елементів на сторінці може бути декілька. Для елемента доступні атрибути media, scoped, type, а також глобальні атрибути. Всередину цього елемента можна записувати код форматування як самих елементів сторінки, так і сторінки цілком.

```css
<style type="text/css">
.paper 
{
	width: 200px;
	height: 300px;
	background-color: #ef4444;
	color: #666666;
}
</style>
```

Щоб підключити до елементу заданий стиль, необхідно через атрибут class (або id) привласнити елементу відповідну назву:

```html 
<div class="paper">
...
<div>
```

CSS-код можна вбудовувати безпосередньо в елемент розмітки у вигляді значення атрибута style, наприклад:

```html 
<p style="color: #666666; background-color: #ef4444; padding: 20px;">
    </p>
```

### Елемент `<SCRIPT>`

Елемент `<script`> дозволяє приєднувати до документа різні сценарії. Закриваючий тег обов'язковий, при цьому текст сценарію може розташовуватися або всередині цього елемента, або в зовнішньому файлі. Якщо текст сценарію розташований в зовнішньому файлі, то він підключається за допомогою атрибутів елемента. Для елемента доступні атрибути async, charset, defer, src, type, а також глобальні атрибути.

### Елемент `<BODY>`

В цьому розділі знаходиться весь вміст документа. Для елемента доступні глобальні атрибути.

HTML теги є основою мови HTML. Кожен тег містить певну інформацію, яка може описувати документ загалом або спосіб форматування тексту. Весь вміст веб-сторінки задається за допомогою тегів. Тег поміщається в кутові дужки <тег>. Найчастіше для тегу задається парний закриваючий тег, але в деяких випадках він відсутній.

Інформація, що розміщена між відкриваючим і закриваючим тегом, називається його контейнером.

В таблиці [http://html5book.ru/html-tags/](http://html5book.ru/html-tags/) наведено повний перелік тегів, що підтримуються HTML4 и HTML5.

У тегів також можуть бути атрибути. HTML атрибути повідомляють браузеру, яким чином має відображатися той чи інший елемент сторінки. Атрибути дозволяють зробити більш різноманітними зовнішній вигляд інформації, доданої за допомогою однакових тегів. Значення атрибута завжди заключають в лапки "". Назви та значення атрибутів не чутливі до регістру, але, тим не менш, рекомендується набирати їх у нижньому регістрі.

`<тег атрибут1="значення1" атрибут2="значення1 значення2">контент</тег>`

Універсальні атрибути можуть бути використані для будь-якого HTML-елемента, власні атрибути тільки для певного типу тегі

Умовно теги можна поділити на групи

*   **Блокові елементи** . Характеризуються тим, що займають всю доступну ширину, висота елемента визначається його вмістом, і він завжди починається з нового рядка.
*   **Рядкові елементи**. Є безпосередньою частиною іншого елемента, наприклад, текстового абзацу. В основному використовуються для зміни вигляду тексту або його логічного виділення.

## Теми для самостійного вивчення

1.  Історія появи та розвитку HTTP
2.  HTTP Cookie
3.  Історія появи та розвитку HTML
4.  Історія появи та розвитку CSS
5.  Поява та призначення консорціуму W3C
6.  "Війни браузерів"
7.  Розвиток та занепад мови XHTML

## Контрольні питання

1.  Що таке тег?
2.  Що таке атрибут?
3.  Що таке контейнерний тег?
4.  Яким чином додати до документа сценарій JavaScript?
5.  Яким чином додати до документа стилі CSS?