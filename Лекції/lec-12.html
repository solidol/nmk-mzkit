<!DOCTYPE html>
<html>
<head>
	<title>МЗКІТ. Лекція №12 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">МЗКІТ. Лекція №12 </div>
		<ul class="lec-menu">
			<li><a href="index.html">Зміст</a></li>
			<li><a href="lec-01.html">01</a></li>
			<li><a href="lec-02.html">02</a></li>
			<li><a href="lec-03.html">03</a></li>
			<li><a href="lec-04.html">04</a></li>
			<li><a href="lec-05.html">05</a></li>
			<li><a href="lec-06.html">06</a></li>
			<li><a href="lec-07.html">07</a></li>
			<li><a href="lec-08.html">08</a></li>
			<li><a href="lec-09.html">09</a></li>
			<li><a href="lec-10.html">10</a></li>
			<li><a href="lec-11.html">11</a></li>
			<li><a href="lec-12.html">12</a></li>
			<li><a href="lec-13.html">13</a></li>
			<li><a href="lec-14.html">14</a></li>
			<li><a href="lec-15.html">15</a></li>
			<li><a href="lec-16.html">16</a></li>
		</ul>
		<h1>Об'єкти та методи у мові JavaScript</h1>
		<h1 id="-">Об'єкт</h1>
<p>Як ми знаємо з розділу <info: types>, в JavaScript існує 8 типів даних. Сім з них називаються "примітивними", так як містять тільки одне значення (будь то рядок, число або щось інше).</p>
<p>Об'єкти ж використовуються для зберігання колекцій різних значень і більш складних сутностей. У JavaScript об'єкти використовуються дуже часто, це одна з основ мови. Тому ми повинні зрозуміти їх, перш ніж заглиблюватися куди-небудь ще.</p>
<p>Об'єкт може бути створений за допомогою фігурних дужок '{ ... } ' з необов'язковим списком <em> властивостей</em>. Властивість-це пара "ключ: значення", де ключ - це рядок (також називається" ім'ям властивості"), а значення може бути чим завгодно.</p>
<p>Ми можемо представити об'єкт у вигляді ящика з підписаними папками. Кожен елемент даних зберігається в своїй папці, на якій написаний ключ. По ключу папку легко знайти, видалити або додати в неї що-небудь.</p>
<p><img src="object.svg" alt=""></p>
<p>Порожній об'єкт ("порожній ящик") можна створити, використовуючи один з двох варіантів синтаксису:</p>
<pre>let user = new Object (); // синтаксис " конструктор об'єкта"
let user = {}; // синтаксис " літерал об'єкта"
</pre>

<p><img src="object-user-empty.svg" alt=""></p>
<p>Зазвичай використовують варіант з фігурними дужками {...}. Таке оголошення називають <em> літералом об'єкта</em>або <em> літеральною нотацією</em>.</p>
<h2 id="-">Літерали і властивості</h2>
<p>При використанні літерального синтаксису' {...}' ми відразу можемо помістити в об'єкт кілька властивостей у вигляді пар " ключ: значення":</p>
<pre>let user = {//об'єкт
name: "John", // під ключем "name" зберігається значення " John"
age: 30 // під ключем "age" зберігається значення 30
};
</pre>

<p>Кожна властивість має ключ (також називається "ім'я" або "ідентифікатор"). Після імені властивості слід двокрапка":", і потім вказується значення властивості. Якщо в об'єкті кілька властивостей, то вони перераховуються через кому.</p>
<p>В об'єкті 'user' зараз знаходяться дві властивості:</p>
<ol>
<li>Перша властивість з ім'ям "name" і значенням "John".</li>
<li>Друга властивість з ім'ям " age " і значенням 30.</li>
</ol>
<p>Можна сказати, що наш об'єкт 'user' - це ящик з двома папками, підписаними "name" і "age".</p>
<p><img src="object-user.svg" alt="user object"></p>
<p>Ми можемо в будь-який момент додати в нього нові папки, видалити папки або прочитати вміст будь-якої папки.</p>
<p>Для звернення до властивостей використовується запис " через точку":</p>
<pre>// отримуємо властивості об'єкта:
alert( user.name ); // John
alert( user.age ); // 30
</pre>

<p>Значення може бути будь-якого типу. Давайте додамо властивість з логічним значенням:</p>
<pre>user.isAdmin = true;
</pre>

<p><img src="object-user-isadmin.svg" alt="user object 2"></p>
<p>Для видалення властивості ми можемо використовувати оператор ' delete':</p>
<pre>delete user.age;
</pre>

<p><img src="object-user-delete.svg" alt="user object 3"></p>
<p>Ім'я властивості може складатися з декількох слів, але тоді воно повинно бути укладено в лапки:</p>
<pre>let user = {
name: "John",
age: 30,
"likes birds": true // ім'я властивості з декількох слів має бути в лапках
};
</pre>

<p><img src="object-user-props.svg" alt=""></p>
<p>Остання властивість об'єкта може закінчуватися комою:</p>
<pre>let user = {
name: "John",
age: 30,
}
</pre>

<p>Це називається "висяча кома". Такий підхід спрощує додавання, видалення і переміщення властивостей, так як всі рядки об'єкта стають однаковими.</p>
<p>""smart header=" Об'єкт, оголошений як константа, може бути змінений"
Об'єкт, оголошений через 'const', <em> може </em> бути змінений.</p>
<p>Наприклад:</p>
<pre>
const user = {
name: "John"
};
user.name = "Pete"; 
alert(user.name); 
</pre>

<p>
Може здатися, що рядок ' ( * ) ' повинна викликати помилку, але ні, тут все в порядку. Справа в тому, що оголошення' const 'захищає від змін тільки саму змінну' user', а не її вміст.
</p>

<p>Визначення 'const' видасть помилку тільки якщо ми присвоїмо змінній інше значення: 'user=...'.</p>

<h2 id="-">Квадратні дужки</h2>

<p>Для властивостей, імена яких складаються з декількох слів, доступ до значення "через точку" не працює:</p>

<pre>
// це викличе синтаксичну помилку
user.likes birds = true;
</pre>


<p>
JavaScript бачить, що ми звертаємося до властивості ' user.likes', а потім йде незрозуміле слово 'birds'. В результаті синтаксична помилка.</p>

<p>Точка вимагає, щоб ключ був іменований за правилами іменування змінних. Тобто не мав прогалин, не починався з цифри і не містив спеціальні символи, крім '$' і '_'.</p>

<p>Для таких випадків існує альтернативний спосіб доступу до властивостей через квадратні дужки. Такий спосіб спрацює з будь-яким ім'ям властивості:</p>

<pre>
let user = {};

// присвоювання значення властивості
user["likes birds"] = true;

// отримання значення властивості
alert(user["likes birds"]); // true

// видалення властивості
delete user["likes birds"];
</pre>


<p>Зараз все гаразд. Зверніть увагу, що рядок в квадратних дужках укладена в лапки (підійде будь-який тип лапок).</p>

<p>Квадратні дужки також дозволяють звернутися до властивості, ім'я якого може бути результатом виразу. Наприклад, ім'я властивості може зберігатися у змінній:</p>

<pre>
let key = "likes birds";
// те ж саме, що і user ["likes birds"] = true;
user[key] = true;
</pre>


<p>Тут змінна ' key ' може бути обчислена під час виконання коду або залежати від призначеного для користувача введення. Після цього ми використовуємо її для доступу до властивості. Це дає нам велику гнучкість.</p>
<p>Приклад:</p>
<pre>
let user = {
name: "John",
age: 30
};
let key = prompt ("що ви хочете дізнатися про Користувача?", "name");
// доступ до властивості через змінну
alert (user[key]); // John (якщо ввели " name")
</pre>

<p>
Запис "через точку" такого не дозволяє:
</p>
<pre>
let user = {
name: "John",
age: 30
};

let key = "name";
alert( user.key ); // undefined
</pre>


<h3 id="-">Обчислювані властивості</h3>
<p>Ми можемо використовувати квадратні дужки в літеральній нотації для створення <em> обчислюваної властивості</em>.</p>
<p>Приклад:</p>
<pre>
let fruit = prompt ("який фрукт купити?", "apple");
let bag = {

[fruit]: 5, // ім'я властивості буде взято зі змінної fruit

};
alert( bag.apple); // 5, якщо fruit= " apple"
</pre>

<p>
Сенс обчислюваної властивості простий: запис '[fruit]' означає, що ім'я властивості необхідно взяти зі змінної 'fruit'.

І якщо Відвідувач введе слово '"apple"', то в об'єкті 'bag' тепер буде лежати властивість '{apple: 5}'.

По суті, приклад вище працює так само, як і наступний приклад:</p>

<pre>
let fruit = prompt ("який фрукт купити?", "apple");
let bag = {};

// ім'я властивості буде взято зі змінної fruit
bag[fruit] = 5;
</pre>

<p>Ми можемо використовувати і більш складні вирази в квадратних дужках:</p>
<pre>let fruit = 'apple';
let bag = {
[fruit + 'Computers']: 5 // bag.appleComputers = 5
};
</pre>

<p>Квадратні дужки дають набагато більше можливостей, ніж запис через точку. Вони дозволяють використовувати будь-які імена властивостей і змінні, хоча і вимагають більш громіздких конструкцій коду.</p>
<p>Підіб'ємо підсумок: у більшості випадків, коли Імена властивостей відомі і прості, використовується запис через точку. Якщо ж нам потрібно щось більш складне, то ми використовуємо квадратні дужки.</p>
<h2 id="-">Властивість зі змінної</h2>
<p>У реальному коді часто нам необхідно використовувати існуючі змінні як значення для властивостей з тим же ім'ям.</p>
<p>Наприклад:</p>
<pre>
function makeUser(name, age) {
return {
name: name,
age: age
// ...інші властивості
};
}
let user = makeUser("John", 30);
alert(user.name); // John
</pre>

<p>
У прикладі вище назва властивостей ' name' і 'age' збігаються з назвами змінних, які ми підставляємо в якості значень цих властивостей. Такий підхід настільки поширений, що існують спеціальні * короткі властивості * для спрощення цього запису.

Замість 'name 'name' ми можемо написати просто ' name':
</p>



<pre>
function makeUser(name, age) {
return {
name, // те ж саме, що і name: name
age // те ж саме, що і age: age
// ...
};
}
</pre>

<p>Ми можемо використовувати як звичайні властивості, так і короткі в одному і тому ж об'єкті:</p>
<pre>
let user = {
name, // те ж саме, що і name: name
age: 30
};
</pre>

<h2 id="-">Обмеження на Імена властивостей</h2>
<p>Як ми вже знаємо, ім'я змінної не може збігатися з зарезервованими словами, такими як" for"," let"," return " і т. д.</p>
<p>Але для властивостей об'єкта такого обмеження немає:</p>

<pre>
// ці імена властивостей допустимі
let obj = {
for: 1,
let: 2,
return: 3
};
alert( obj.for + obj.let + obj.return ); // 6</p>
</pre>


<p>Іншими словами, немає ніяких обмежень до Імен властивостей. Вони можуть бути у вигляді рядків або символів (спеціальний тип для ідентифікаторів, який буде розглянуто пізніше).

Всі інші типи даних будуть автоматично перетворені до рядка.

Наприклад, якщо використовувати число '0' в якості ключа, то воно перетвориться в рядок ' "0"':</p>

<pre>
let obj = {
0: "Тест" // те ж саме що і "0": "Тест"
};

// обидві функції alert виведуть одне і те ж властивість (число 0 перетворюється в рядок " 0")
alert (obj["0"]); // Тест
alert (obj[0]); // Тест (те ж властивість)
</pre>

<p>Є невеликий підводний камінь, пов'язаний зі спеціальною властивістю _ _ proto__. Ми не можемо встановити його в необ'єктне значення:</p>
<pre>
let obj = {};
obj.proto  = 5; // присвоїмо число
alert(obj.__proto__); // [object Object], значення-це об'єкт, тобто не те, що ми очікували
</pre>

<p>
Як ми бачимо, присвоєння примітивного значення '5' ігнорується.

Ми більш детально досліджуємо особливості властивості '__proto__' в наступних розділах [], а також запропонуємо [способи виправлення] такої поведінки.</p>

<h2>Перевірка існування властивості, оператор "in"</h2>

На відміну від багатьох інших мов, особливість JavaScript-об'єктів в тому, що можна отримати доступ до будь-якої властивості. Навіть якщо властивості не існує - помилки не буде!

При зверненні до властивості, якого немає, повертається 'undefined'. Це дозволяє просто перевірити існування властивості:

<pre>
let user = {};

alert( user.noSuchProperty = = = undefined); // true означає " властивості немає"
</pre>


<p>Також існує спеціальний оператор "in" для перевірки існування властивості в об'єкті.</p>
<p>Синтаксис оператора:</p>
<pre>"key" in object
</pre>

<p>Приклад:</p>
<pre>
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age існує
alert( "blabla" in user ); // false, user.blabla не існує
</pre>

<p>
Зверніть увагу, що зліва від оператора' in ' має бути * ім'я властивості*. Зазвичай це рядок в лапках.

Якщо ми опускаємо лапки, це означає, що ми вказуємо змінну, в якій знаходиться ім'я властивості. Наприклад:
</p>
<pre>
let user = { age: 30 };

let key = "age";
alert( key in user); // true, ім'я властивості було взято зі змінної key
</pre>

<p>Для чого взагалі потрібен оператор in? Хіба недостатньо порівняння з ' undefined'?</p>
<p>У більшості випадків прекрасно спрацює порівняння з 'undefined'. Але є особливий випадок, коли воно не підходить, і потрібно використовувати "in".</p>
<p>Це коли властивість існує, але містить значення ' undefined':</p>
<pre>
let obj = {
test: undefined
};
alert( obj.test); // виведе undefined, значить властивість не існує?
alert ("test" in obj ); // true, властивість існує!</p>
</pre>

<p>
У прикладі вище властивість ' obj.test ' технічно існує в об'єкті. Оператор 'in' спрацював правильно.

Подібні ситуації трапляються дуже рідко, так як' undefined ' зазвичай явно не присвоюється. Для" невідомих "або" порожніх "властивостей ми використовуємо значення' null'. Таким чином, оператор 'in' є екзотичним гостем в коді.

<h2> Цикл "for..in"</h2>

<p>
Для перебору всіх властивостей об'єкта використовується цикл 'for..in'. цей цикл відрізняється від вивченого раніше циклу ' for (;;)'.

Синтаксис:</p>

<pre>
for (key in object) {
// тіло циклу виконується для кожного властивості об'єкта
}
</pre>

<p>Наприклад, давайте виведемо всі властивості об'єкта ' user':</p>
<pre>
let user = {
name: "John",
age: 30,
isAdmin: true
};
for (let key in user) {
// ключ
alert( key ); // name, age, isAdmin
// значення ключів
alert( user[key] ); // John, 30, true
}
</pre>

<p>
Зверніть увагу, що всі конструкції " for " дозволяють нам оголошувати змінну всередині циклу, як, наприклад, 'let key' тут.

Крім того, ми могли б використовувати інше ім'я змінної. Наприклад, часто використовується варіант " for (let prop in obj)".</p>

<h3>Упорядкування властивостей об'єкта</h3>

<p>
Чи впорядковані властивості об'єкта? Іншими словами, якщо ми будемо в циклі перебирати всі властивості об'єкта, чи отримаємо ми їх в тому ж порядку, в якому ми їх додавали? Чи можемо ми на це розраховувати?

Коротка відповідь: властивості впорядковані особливим чином: властивості з цілочисельними ключами сортуються за зростанням, інші розташовуються в порядку створення. Розберемося докладніше.

Як приклад розглянемо об'єкт з телефонними кодами:
</p>
<pre>
let codes = {
"49": "Німеччина",
"41": "Швейцарія",
"44": "Великобританія",
// ..,
"1": "США"
};

for (let code in codes) {
alert(code); // 1, 41, 44, 49
}
</pre>

<p>Якщо ми робимо сайт для німецької аудиторії, то, ймовірно,ми хочемо, щоб код 49 був першим.</p>
<p>Але якщо ми запустимо код, ми побачимо зовсім іншу картину:</p>
<ul>
<li>США (1) йде першим</li>
<li>потім Швейцарія (41) і так далі.</li>
</ul>
<p>Телефонні коди йдуть в порядку зростання, тому що вони є цілими числами: 1, 41, 44, 49.</p>
<p>""smart header=" цілочисельні властивості? Це що?"
Термін "цілочисельна властивість" означає рядок, яка може бути перетворена в ціле число і назад без змін.</p>
<p>Тобто, "49" - це цілочисельне ім'я властивості, тому що якщо його перетворити в ціле число, а потім назад в рядок, то воно не зміниться. А ось властивості " + 49 " або "1.2' такими не є:</p>
<pre>
// Math.trunc-вбудована функція, яка видаляє десяткову частину
alert( String(Math.trunc (Number("49"))) ); // "49", те ж саме ⇒ властивість цілочисельне
alert( String(Math.trunc (Number("+49"))) ); // "49", не те ж саме, що "+49" ⇒ властивість не цілочисельна
alert( String(Math.trunc (Number("1.2"))) ); // "1", не те ж саме, що "1.2" ⇒ властивість не цілочисельна</p>
</pre>

<p>...З іншого боку, якщо ключі не цілочисельні, то вони перебираються в порядку створення, наприклад:</p>
<pre>
let user = {
name: "John",
surname: "Smith"
};
user.age = 25; // додамо ще одну властивість
// не цілочисельні властивості перераховані в порядку створення
for (let prop in user) {
alert( prop ); // name, surname, age
}
</pre>

<p>
Таким чином, щоб вирішити нашу проблему з телефонними кодами, ми можемо схитрувати, зробивши коди не цілочисельними властивостями. Додавання знака " + " перед кожним кодом буде достатньо.

Приклад:
</p>
<pre>
let codes = {
"+49": "Німеччина",
"+41": "Швейцарія",
"+44": "Великобританія",
// ..,
"+1": "США"
};

for (let code in codes) {
alert( +code ); // 49, 41, 44, 1
}
</pre>

<p>Тепер код працює так, як ми задумували.</p>
<h2 id="-">Разом</h2>
<p>Об'єкти-це асоціативні масиви з рядом додаткових можливостей.</p>
<p>Вони зберігають властивості (пари ключ-значення), де:</p>
<ul>
<li>Ключі властивостей повинні бути рядками або символами (зазвичай рядками).</li>
<li>Значення можуть бути будь-якого типу.</li>
</ul>
<p>Щоб отримати доступ до властивості, ми можемо використовувати:</p>
<ul>
<li>Запис через точку: obj.property.</li>
<li>Квадратні дужки ' obj ["property"]. Квадратні дужки дозволяють взяти ключ зі змінної, наприклад, ' obj[varWithKey].</li>
</ul>
<p>Додаткові оператори:</p>
<ul>
<li>Видалення властивості ' delete obj.prop.</li>
<li>Перевірка існування властивості: " key " in obj.</li>
<li>Перебір властивостей об'єкта:цикл for ' for (let key in obj)'.</li>
</ul>
<p>Те, що ми вивчали в цьому розділі, називається "простим об'єктом" ("plain object") або просто Object.</p>
<p>У JavaScript є багато інших типів об'єктів:</p>
<p>'Array' для зберігання впорядкованих колекцій даних,'Dateдля зберігання інформації про дату і час,'Error' для зберігання інформації про помилку.</p>
<ul>
<li>... і так далі.</li>
</ul>
<p>У них є свої особливості, які ми вивчимо пізніше. Іноді люди говорять щось на кшталт "тип даних Array "або" тип даних Date", але формально вони не є окремими типами, а відносяться до типу даних Object. Вони лише розширюють його різними способами.</p>
<p>Об'єкти в JavaScript дуже потужні. Тут ми тільки трохи заглибилися в дійсно величезну тему. Ми будемо щільно працювати з об'єктами і дізнаємося про них більше в наступних частинах підручника.</p>
<!--  -->
<h1 id="-">Копіювання об'єктів і посилання</h1>
<p>Однією з фундаментальних відмінностей об'єктів від примітивних типів даних є те, що вони зберігаються і копіюються "за посиланням".</p>
<p>Примітивні типи: рядки, числа, логічні значення - присвоюються і копіюються "за значенням".</p>
<p>Наприклад:</p>
<pre>let message = " Привіт!";
let phrase = message;
</pre>

<p>В результаті ми маємо дві незалежні змінні, кожна з яких зберігає рядок " Привіт!".</p>
<p><img src="variable-copy-value.svg" alt=""></p>
<p>Об'єкти поводяться інакше.</p>
<p><strong> Змінна зберігає не сам об'єкт, а його "адресу в пам'яті", іншими словами "посилання" на нього.</strong></p>
<p>Проілюструємо це:</p>
<pre>let user = {
name: "Іван"
};
</pre>

<p><img src="variable-contains-reference.svg" alt=""></p>
<p>Сам об'єкт зберігається десь в пам'яті. А в змінній 'user' лежить "посилання" на цю область пам'яті.</p>
<p><strong> Коли змінна об'єкта копіюється-копіюється посилання, сам же об'єкт не дублюється.</strong></p>
<p>Якщо ми представляємо об'єкт як ящик, то змінна-це ключ до нього. Копіювання змінної дублює ключ, але не сам ящик.</p>
<p>Наприклад:</p>
<pre>
let user = { name: "Іван" };
let admin = user; // копіюється посилання
</pre>

<p>
Тепер у нас є дві змінні, кожна з яких містить посилання на один і той же об'єкт:
</p>

<img src="variable-copy-reference.svg" alt="">
<p>
Ми можемо використовувати будь-яку з змінних для доступу до ящика і зміни його вмісту:
</p>
<pre>
let user = { name: 'Іван' };

let admin = user;

admin.name = 'Петя'; // змінено за посиланням зі змінної " admin"

alert(user.name); // 'Петя', зміни видно за посиланням зі змінної " user"
</pre>

<p>Наведений вище приклад демонструє, що об'єкт тільки один. Як якщо б у нас був один ящик з двома ключами і ми використовували один з них (admin), щоб увійти в нього і щось змінити, а потім, відкривши ящик іншим ключем (user), ми б побачили ці зміни.</p>
<h2 id="-">Порівняння за посиланням</h2>
<p>Оператори рівності == і суворої рівності ' = = = ' для об'єктів працюють однаково.</p>
<p><strong> Два об'єкти рівні тільки в тому випадку, якщо це один і той же об'єкт.</strong></p>
<p>У прикладі нижче дві змінні посилаються на один і той же об'єкт, тому вони рівні один одному:</p>
<pre>
let a = {};
let b = a; // копіювання за посиланням
alert (a = = b); // true, тому що обидві змінні посилаються на один і той же об'єкт
alert( a === b ); // true
</pre>

<p>В іншому прикладі два різних об'єкти не рівні, хоча обидва порожні:</p>

<pre>
let a = {};
let b = {}; // два незалежних об'єкта

alert( a == b ); // false
</pre>


<p>Для порівнянь типу 'obj1 &gt; obj2' або для порівняння з примітивом obj == 5 об'єкти перетворюються в примітиви. Ми скоро вивчимо, як працюють такі перетворення об'єктів, але, по правді кажучи, порівняння такого роду необхідні дуже рідко і зазвичай є результатом помилки програміста.</p>
<h2 id="-object-assign">Клонування та об'єднання об'єктів, Object . assign</h2>
<p>Таким чином, при копіюванні змінної з об'єктом створюється ще одне посилання на той же самий об'єкт.</p>
<p>Але що, якщо нам все ж потрібно дублювати об'єкт? Створити незалежну копію, клон?</p>
<p>Це здійсненно, але трохи складно, так як в JavaScript немає вбудованого методу для цього. Насправді, така потреба виникає рідко. У більшості випадків нам достатньо копіювання за посиланням.</p>
<p>Але якщо ми дійсно цього хочемо, то нам потрібно створювати новий об'єкт і повторювати структуру дубльованого об'єкта, перебираючи його властивості і копіюючи їх.</p>
<p>Наприклад так:</p>
<pre>
let user = {
name: "Іван",
age: 30
};
let clone = {}; // новий порожній об'єкт
// скопіюємо всі властивості user в нього
for (let key in user) {
clone[key] = user[key];
}
</pre>

<p>// тепер у змінній clone знаходиться абсолютно незалежний клон об'єкта
clone.name = "Петро"; // змінимо в ньому дані</p>
<p>alert( user.name ); // в оригінальному об'єкті значення властивості name залишилося колишнім – Іван.</p>
<p>
Крім того, для цих цілей ми можемо використовувати метод [Object.assign](mdn:js/Object/assign). Синтаксис:
</p>


<pre>
Object.assign(dest, [src1, src2, src3...])
</pre>

<ul>
<li>Перший аргумент dest - цільовий об'єкт.</li>
<li>Інші аргументи src1, ..., srcN (може бути стільки, скільки потрібно)) є вихідними об'єктами</li>
<li>Метод копіює властивості всіх вихідних об'єктів src1, ..., srcN ' в цільовий об'єктdest'. Тобто, властивості всіх перерахованих об'єктів, починаючи з другого, копіюються в перший об'єкт.</li>
<li>Повертає об'єкт 'dest'.</li>
</ul>
<p>Наприклад, об'єднаємо кілька об'єктів в один:</p>
<pre>let user = { name: "Іван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копіюємо всі властивості з permissions1 і permissions2 в user
Object.assign(user, permissions1, permissions2);
// тепер user = { name: "Іван", canView: true, canEdit: true }
</pre>

<p>Якщо приймаючий об'єкт ('user') вже має властивість з таким ім'ям, воно буде перезаписано:</p>
<pre>
let user = { name: "Іван" };
Object.assign (user, { name: "Петро" });
alert(user.name); // тепер user = { name: "Петро" }</p>
</pre>
<p>
Ми також можемо використовувати ' Object 'assign' для заміни 'for..in' на просте клонування:
</p>
<pre>
let user = {
name: "Іван",
age: 30
};
let clone = Object.assign({}, user);
</pre>
<p>Цей метод скопіює всі властивості об'єкта 'user' в порожній об'єкт і поверне його.</p>
<h2 id="-">Вкладене клонування</h2>
<p>До цих пір ми припускали, що всі властивості об'єкта ' user' зберігають примітивні значення. Але властивості можуть бути посиланнями на інші об'єкти. Що з ними робити?</p>
<p>Наприклад, є об'єкт:
<pre>
let user = {
name: "Іван",
sizes: {
height: 182,
width: 50
}
};
alert( user.sizes.height ); // 182</p>
</pre>
Тепер при клонуванні недостатньо просто скопіювати ' clone 'sizes = user.sizes', оскільки ' user.sizes' - це об'єкт, він буде скопійований за посиланням. А значить об'єкти 'clone' і 'user' в своїх властивостях' sizes ' будуть посилатися на один і той же об'єкт:

<pre>
let user = {
name: "Іван",
sizes: {
height: 182,
width: 50
}
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes); // true, один і той же об'єкт

// user і clone звертаються до одного sizes
user.sizes.width++; // міняємо властивість в одному об'єкті
alert(clone.sizes.width); // 51, бачимо результат в іншому об'єкті
</pre>
<p>Щоб виправити це, ми повинні в циклі клонування робити перевірку, чи не є значення user[key] об'єктом, і якщо це так-скопіювати і його структуру теж. Це називається "глибоке клонування".</p>
<p>Ми можемо реалізувати глибоке клонування, використовуючи рекурсію. Або, щоб не винаходити велосипед, використовувати готову реалізацію-метод [_. cloneDeep(obj)] (<a href="https://lodash.com/docs#cloneDeep">https://lodash.com/docs#cloneDeep</a>) з JavaScript-бібліотеки <a href="https://lodash.com">lodash</a>.</p>
<h2 id="-">Разом</h2>
<p>Об'єкти присвоюються і копіюються за посиланням. Іншими словами, змінна зберігає не "Значення об'єкта", а" Посилання " (адреса в пам'яті) на це значення. Тому копіювання такої змінної або передача її в якості аргументу функції призводить до копіювання цього посилання, а не самого об'єкта.</p>
<p>Всі операції з використанням скопійованих посилань (наприклад, додавання або видалення властивостей) виконуються з одним і тим же об'єктом.</p>
<p>Для "простого клонування" об'єкта можна використовувати ' Object.assign. Необхідно пам'ятати, щоObject.assign ' не робить глибоке клонування об'єкта. Якщо всередині копіюваного об'єкта є властивість значення, якого не є примітивом, воно буде передано за посиланням. Для створення "справжньої копії" (повного клону об'єкта) можна скористатися методом зі сторонньої JavaScript-бібліотеки [_. cloneDeep(obj)] (<a href="https://lodash.com/docs#cloneDeep">https://lodash.com/docs#cloneDeep</a>).</p>
<h1 id="-">Збирання сміття</h1>
<p>Управління пам'яттю в JavaScript виконується автоматично і непомітно. Ми створюємо примітиви, об'єкти, функції... Все це займає пам'ять.</p>
<p>Але що відбувається, коли щось більше не потрібно? Як JavaScript розуміє, що пора очищати пам'ять?</p>
<h2 id="-">Досяжність</h2>
<p>Основною концепцією управління пам'яттю в JavaScript є принцип <em> досяжності</em>.</p>
<p>Якщо спростити, то" досяжні " значення-це ті, які доступні або використовуються. Вони гарантовано знаходяться в пам'яті.</p>
<ol>
<li>Існує базове безліч досяжних значень, які не можуть бути видалені.</li>
</ol>
<p>Наприклад:</p>
<ul>
<li>Локальні змінні і параметри поточної функції.</li>
<li>Змінні та параметри інших функцій у поточному ланцюжку вкладених викликів.</li>
<li>Глобальна змінна.</li>
<li>(деякі інші внутрішні значення)</li>
</ul>
<p>Ці значення ми будемо називати <em> корінням</em>.</p>
<ol>
<li>Будь-яке інше значення вважається досяжним, якщо воно доступне з кореня за посиланням або по ланцюжку посилань.</li>
</ol>
<p>Наприклад, якщо в локальній змінній є об'єкт, і він має властивість, в якій зберігається посилання на інший об'єкт, то цей об'єкт вважається досяжним. І ті, на які він посилається, теж досяжні. Далі ви познайомитеся з докладними прикладами на цю тему.</p>
<p>В інтерпретаторі JavaScript є фоновий процес, який називається <a href="https://ru.wikipedia.org/wiki/Сборка_мусора">збирач сміття</a>. він стежить за всіма об'єктами і видаляє ті, які стали недосяжні.</p>
<h2 id="-">Простий приклад</h2>
<p>Ось найпростіший приклад:</p>
<pre>// в user знаходиться посилання на об'єкт
let user = {
name: "John"
};
</pre>

<p><img src="memory-user-john.svg" alt=""></p>
<p>Тут стрілка позначає посилання на об'єкт. Глобальна змінна 'user' посилається на об'єкт '{name "John"} (ми будемо називати його просто "John"). У властивості'" name "' об'єкта John зберігається примітив, тому воно намальовано всередині об'єкта.</p>
<p>Якщо перезаписати значення ' user', то посилання загубиться:</p>
<pre>user = null;
</pre>

<p><img src="memory-user-john-lost.svg" alt=""></p>
<p>Тепер Об'єкт John стає недосяжним. До нього немає доступу, на нього немає посилань. Збирач сміття видалить ці дані і звільнить пам'ять.</p>
<h2 id="-">Два посилання</h2>
<p>Уявімо, що ми скопіювали посилання з 'user' в ' admin':</p>
<pre>// в user знаходиться посилання на об'єкт
let user = {
name: "John"
};


let admin = user;

</pre>

<p><img src="memory-user-john-admin.svg" alt=""></p>
<p>Тепер, якщо ми зробимо те ж саме:</p>
<pre>user = null;
</pre>

<p>...те об'єкт John все ще досяжний через глобальну змінну ' admin, тому він знаходиться в пам'яті. Якби ми також перезаписали ' admin, то John був би видалений.</p>
<h2 id="-">Взаємопов'язані об'єкти</h2>
<p>Тепер більш складний приклад. Сім'я:</p>
<pre>function marry(man, woman) {
woman.husband = man;
man.wife = woman;

return {
father: man,
mother: woman
}
}

let family = marry({
name: "John"
}, {
name: "Ann"
});
</pre>

<p>Функція ' marry' "одружує" два об'єкти, даючи їм посилання один на одного, і повертає новий об'єкт, що містить посилання на два попередніх.</p>
<p>В результаті отримуємо таку структуру пам'яті:</p>
<p><img src="family.svg" alt=""></p>
<p>На даний момент всі об'єкти досяжні.</p>
<p>Тепер видалимо два посилання:</p>
<pre>delete family.father;
delete family.mother.husband;
</pre>

<p><img src="family-delete-refs.svg" alt=""></p>
<p>Недостатньо видалити лише одну з цих посилань, оскільки всі об'єкти залишаться досяжними.</p>
<p>Але якщо ми видалимо обидві, то побачимо, що у об'єкта John більше немає вхідних посилань:</p>
<p><img src="family-no-father.svg" alt=""></p>
<p>Вихідні посилання не мають значення. Тільки вхідні посилання можуть зробити об'єкт досяжним. Об'єкт John тепер недосяжний і буде видалений з пам'яті з усіма своїми даними, які також стали недоступні.</p>
<p>Після збирання сміття:</p>
<p><img src="family-no-father-2.svg" alt=""></p>
<h2 id="-">Недосяжний " Острів"</h2>
<p>Цілком можлива ситуація, при якій цілий "острів" пов'язаних об'єктів може стати недосяжним і піти з пам'яті.</p>
<p>Візьмемо об'єкт family з прикладу вище. А тоді:</p>
<pre>family = null;
</pre>

<p>Структура в пам'яті тепер стане такою:</p>
<p><img src="family-no-family.svg" alt=""></p>
<p>Цей приклад демонструє, наскільки важлива концепція досяжності.</p>
<p>Об'єкти John і Ann все ще пов'язані, обидва мають вхідні посилання, але цього недостатньо.</p>
<p>У об'єкта 'family' більше немає посилання від кореня, тому весь "острів" стає недосяжним і буде видалений.</p>
<h2 id="-">Внутрішні алгоритми</h2>
<p>Основний алгоритм збирання сміття- "алгоритм позначок" (англ. "mark-and-sweep").</p>
<p>Згідно з цим алгоритмом, збирач сміття регулярно виконує наступні кроки:</p>
<ul>
<li>Збирач сміття "позначає "(запам'ятовує) всі кореневі об'єкти.</li>
<li>Потім він йде по їх посиланнях і позначає всі знайдені об'єкти.</li>
<li>Потім він йде по посиланнях позначених об'єктів і позначає об'єкти, на які є посилання від них. Всі об'єкти запам'ятовуються, щоб в майбутньому не відвідувати один і той же об'єкт двічі.</li>
<li>...І так далі, поки не будуть відвідані всі посилання (досяжні від коренів).</li>
<li>Все непозначені об'єкти видаляються.</li>
</ul>
<p>Наприклад, нехай наша структура об'єктів виглядає так:</p>
<p><img src="garbage-collection-1.svg" alt=""></p>
<p>Явно видно" недосяжний Острів " праворуч. Тепер подивимося, як буде працювати "алгоритм позначок" збирача сміття.</p>
<p>На першому кроці позначаються коріння:</p>
<p><img src="garbage-collection-2.svg" alt=""></p>
<p>Потім позначаються об'єкти по їх посиланнях:</p>
<p><img src="garbage-collection-3.svg" alt=""></p>
<p>...а потім об'єкти по їх посиланнях і так далі, поки це взагалі можливо:</p>
<p><img src="garbage-collection-4.svg" alt=""></p>
<p>Тепер об'єкти, до яких не вдалося дійти від коренів, вважаються недосяжними і будуть видалені:</p>
<p><img src="garbage-collection-5.svg" alt=""></p>
<p>Це і є принцип роботи збірки сміття.</p>
<p>Інтерпретатори JavaScript застосовують безліч оптимізацій, щоб збірка сміття працювала швидше і не впливала на продуктивність.</p>
<p>Ось деякі з оптимізацій:</p>
<ul>
<li><em>*Збірка по поколіннях (Generational collection) </em> * - об'єкти діляться на "нові" і "старі". Багато об'єктів з'являються, виконують своє завдання і швидко вмирають, їх можна видаляти більш агресивно. Ті, які живуть досить довго, стають "старими" і перевіряються рідше.</li>
<li><em>*Інкрементальна збірка (Incremental collection) </em> * - якщо об'єктів багато, то обхід всіх посилань і позначка досяжних об'єктів може зайняти значний час і привести до видимих затримок виконання скрипта. Тому інтерпретатор намагається організувати збірку сміття поетапно. Етапи виконуються окремо один за іншим. Це вимагає додаткового обліку для відстеження змін між етапами, але зате тепер у нас є багато крихітних затримок замість однієї великої.</li>
<li><strong>Збірка у вільний час (Idle-time collection)</strong> - щоб зменшити можливий вплив на продуктивність, збирач сміття намагається працювати тільки під час простою процесора.</li>
</ul>
<p>Існують і інші способи оптимізації та різновиди алгоритмів збирання сміття. Але як би мені не хотілося описати їх тут, я повинен утриматися від цього, тому що різні інтерпретатори JavaScript застосовують різні прийоми і хитрощі. І, що більш важливо, все змінюється в міру розвитку інтерпретаторів, тому заглиблюватися в цю тему заздалегідь, без реальної необхідності, ймовірно, не варто. Якщо, звичайно, це не питання чистого інтересу, тоді для вас будуть корисні деякі посилання нижче.</p>
<h2 id="-">Разом</h2>
<p>Головне з того, що ми дізналися:</p>
<ul>
<li>Збірка сміття виконується автоматично. Ми не можемо прискорити або запобігти її.</li>
<li>Об'єкти зберігаються в пам'яті, поки вони досяжні.</li>
<li>Наявність посилання не гарантує, що об'єкт досяжний (від кореня): кілька взаємопов'язаних об'єктів можуть стати недосяжними як єдине ціле.</li>
</ul>
<p>Сучасні інтерпретатори реалізують передові алгоритми збирання сміття.</p>
<p>Деякі з них висвітлені в книзі "The Garbage Collection Handbook: The Art of Automatic Memory Management" (R. Jones та ін.).</p>
<p>Якщо Ви знайомі з низькорівневим програмуванням, то більш детальна інформація про збирача сміття інтерпретатора V8 знаходиться в статті <a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">a tour of V8: Garbage Collection</a>.</p>
<p>Також в <a href="https://v8.dev/">блозі інтерпретатора V8</a> час від часу публікуються статті про зміни в управлінні пам'яттю. Зрозуміло, щоб вивчити збірку сміття, вам необхідно розуміти, як влаштований всередині інтерпретатор V8 в цілому. Про це ви можете почитати в блозі <a href="http://mrale.ph">В'ячеслава Єгорова</a>, одного з інженерів, що розробляли V8. Я говорю про "V8", тому що він найкраще висвітлений статтями в Інтернеті. В інших інтерпретаторах багато підходів схожі, але збірка сміття в багатьох аспектах відрізняється.</p>
<p>Глибоке розуміння роботи інтерпретаторів необхідно, коли вам потрібні низькорівневі оптимізації. Було б розумно запланувати їх вивчення як наступний крок після освоєння мови.</p>
<h1 id="-this-">Методи об'єкта, " this"</h1>
<p>Об'єкти зазвичай створюються, щоб представляти сутності реального світу, будь то користувачі, замовлення і так далі:</p>
<pre>// Об'єкт користувача
let user = {
name: "Джон",
age: 30
};
</pre>

<p>І так само, як і в реальному світі, користувач може <em>здійснювати дії</em>: вибирати щось з кошика покупок, авторизуватися, виходити з системи, оплачувати і т. п.</p>
<p>Такі дії в JavaScript представлені властивостями-функціями об'єкта.</p>
<h2 id="-">Приклади методів</h2>
<p>Для початку давайте навчимо нашого користувача' user ' вітатися:</p>
<pre>
let user = {
name: "Джон",
age: 30
};

user.sayHi = function() {
alert ("Привіт!");
};
user.sayHi (); // Привіт!
</pre>
<p>
Тут ми просто використовували function Expression (функціональний вираз), щоб створити функцію для привітання, і присвоїли її властивості 'user.sayHi ' нашого об'єкта.

Функцію, яка є властивістю об'єкта, називають *методом* цього об'єкта.

Отже, ми отримали метод' sayHi ' об'єкта 'user'.

Звичайно, ми могли б заздалегідь оголосити функцію і використовувати її в якості методу, приблизно так:
</p>
<pre>
let user = {
// ...
};
// спочатку оголошуємо
function sayHi() {
alert ("Привіт!");
};

// потім додаємо в якості методу
user.sayHi = sayHi;
user.sayHi (); // Привіт!
</pre>
<p>
Коли ми пишемо наш код, використовуючи об'єкти для представлення сутностей реального світу, - це називається <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">об'єктно-орієнтоване программирование</a> або скорочено: "ООП".</p>
<p>ООП є великою предметною областю і цікавою наукою саме по собі. Як вибрати правильні сутності? Як організувати взаємодію між ними? Це-створення архітектури , і є хороші книги з цієї теми, такі як " прийоми об'єктно-орієнтованого проектування. Патерни проектування " авторів Еріх гама, Річард Хелм, Ральф Джонсон, Джон Вліссідес або "Об'єктно-орієнтований аналіз і проектування з прикладами додатків", а також ще безліч інших книг.</p>

<h3>Скорочений запис методу

Існує коротший синтаксис для методів в літералі об'єкта:

<pre>
// ці об'єкти роблять одне і те ж (однакові методи)

user = {
sayHi: function() {
alert ("Привіт");
}
};

// скорочений запис виглядає краще, чи не так?
user = {

sayHi () {//те ж саме, що і " sayHi: function()"

alert ("Привіт");
}
};
</pre>
<p>Як було показано, ми можемо пропустити ключове слово "function" і просто написати sayHi ().</p>
<p>Потрібно відзначити, що ці два записи не повністю еквівалентні. Є тонкі відмінності, пов'язані з успадкуванням об'єктів (що буде розглянуто пізніше), але на даному етапі вивчення це неважливо. У більшості випадків скорочений синтаксис кращий.</p>
<h2 id="-this-">Ключове слово "this" в методах</h2>
<p>Як правило, методу об'єкта необхідний доступ до інформації, яка зберігається в об'єкті, щоб виконати з нею будь-які дії (відповідно до призначення методу).</p>
<p>Наприклад, коду всередині ' user.sayHi () 'може знадобитися ім'я користувача, яке зберігається в об'єкті 'user'.</p>
<p><strong> Для доступу до інформації всередині об'єкта метод може використовувати ключове слово 'this'.</strong></p>
<p>Значення 'this' - це об'єкт "перед точкою", який використовувався для виклику методу.</p>
<p>Наприклад:</p>
<pre>
let user = {
name: "Джон",
age: 30, sayHi() {

// this - це " поточний об'єкт"
alert(this.name);

}
};
user.sayHi (); // Джон
</pre>
<p>
Тут під час виконання коду ' user.sayHi () 'значенням' this 'буде' user' (посилання на об'єкт 'user').

Технічно також можливо отримати доступ до об'єкта без ключового слова ' this', посилаючись на нього через зовнішню змінну (в якій зберігається посилання на цей об'єкт):
</p>
<pre>
let user = {
name: "Джон",
age: 30,

sayHi() {

alert(user.name); // використовуємо змінну "user" замість ключового слова "this"

}

};
</pre>
<p>Але такий код буде ненадійним. Якщо ми вирішимо скопіювати посилання на об'єкт 'userв іншу змінну, наприклад' admin = user, і перезапишемо змінну user 'чимось іншим, тоді буде здійснено доступ до неправильного об'єкту при виклику методу з 'admin'.</p>
<p>Це показано нижче:</p>
<pre>
let user = {
name: "Джон",
age: 30,
sayHi() {

alert( user.name ); // призведе до помилки

}
};
let admin = user;
user = null; // обнулимо змінну для наочності, тепер вона не зберігає посилання на об'єкт.
admin.sayHi (); // помилка! Всередині sayHi () використовується user, яка більше не посилається на об'єкт!
</pre>
<p>
Якщо ми використовуємо 'this.name 'замість 'user.name 'всередині' alert', тоді цей код буде працювати.</p>

<h2>"this" не є фіксованим</h2>
<p>
У JavaScript ключове слово "this" поводиться інакше, ніж у більшості інших мов програмування. Воно може використовуватися в будь-якій функції.

У цьому коді немає синтаксичної помилки:
</p>
<pre>
function sayHi() {
alert( this.name );
}
</pre>
<p>Значення ' this' обчислюється під час виконання коду і залежить від контексту.</p>
<p>Наприклад, тут одна і та ж функція призначена двом різним об'єктам і має різне значення" this " при викликах:</p>
<pre>
let user = { name: "Джон" };
let admin = { name: "Адмін" };
function sayHi() {
alert( this.name );
}
// використовуємо одну і ту ж функцію в двох об'єктах
user.f = sayHi;
admin.f = sayHi;
// виклики функції, наведені нижче, мають різне значення this
// "this" всередині функції є посиланням на об'єкт, який вказаний " перед точкою"
user.f (); // Джон (this = = user)
admin.f (); // Адмін (this = = admin)
admin['f'] (); // Адмін (неважливий спосіб доступу до методу-через точку або квадратні дужки)
</pre>
<p>
Правило просте: при виклику 'obj.f()' значення 'this' всередині 'f' дорівнює 'obj'. Так що, в наведеному прикладі це 'user' або 'admin'.
</p>

<pre>
function sayHi() {
alert(this);
}

sayHi(); // undefined
</pre>
<p>У строгому режимі ("use strict") в такому коді значенням this буде undefined. Якщо ми спробуємо отримати доступ до 'name', використовуючи this.name - це викличе помилку.</p>
<p>У нестрогому режимі значенням 'this' в такому випадку буде <em>глобальний об'єкт</em> (window для браузера, ми повернемося до цього пізніше в розділі <a href="info:global-object">Глобальний об'єкт</a>). Це-історично сформована поведінка ' this, яка виправляється використанням суворого режиму ("use strict"').</p>
<p>Зазвичай подібний виклик є помилкою програмування. Якщо всередині функції використовується ' this', тоді очікується, що вона буде викликатися в контексті будь-якого об'єкта.</p>
<p>
"'smart header=" наслідки вільного ' this'"
Якщо ви до цього вивчали інші мови програмування, тоді ви, швидше за все, звикли до ідеї "фіксованого 'this'" - коли методи, визначені всередині об'єкта, завжди зберігають в якості значення 'this' посилання на свій об'єкт (в якому був визначений метод).</p>

<p>
У JavaScript 'this' є "вільним", його значення обчислюється в момент виклику методу і не залежить від того, де цей метод був оголошений, а залежить від того, який об'єкт викликає метод (який об'єкт стоїть"перед точкою").</p>

<p>
Ця ідея обчислення 'this' в момент виконання має як свої плюси, так і мінуси. З одного боку, функція може бути повторно використана в якості методу у різних об'єктів (що підвищує гнучкість). З іншого боку, більша гнучкість збільшує ймовірність помилок.</p>

<p>
Тут ми не будемо судити про те, чи є це рішення в мові хорошим чи поганим. Ми повинні розуміти, як з цим працювати, щоб отримувати вигоди і уникати проблем.
</p>

<h2 id="-">Внутрішня реалізація: Тип посилання</h2>
<p>"'warn header=" Просунута можливість мови"
Цей розділ пояснює складну тему, щоб краще розуміти деякі заплутані випадки.</p>
<p>Якщо ви хочете просуватися швидше, його можна пропустити або відкласти.</p>
<p>
Деякі хитрі способи виклику методу призводять до втрати значення ' this', наприклад:
</p>

<pre>
let user = {
name: "Джон",
hi() { alert(this.name); },
bye () { alert ("поки"); }
};

user.hi (); // Джон (простий виклик методу працює добре)


// тепер давайте спробуємо викликати user.hi або user.bye
// залежно від імені користувача user.name
(user.name = = "Джон"? user.hi : user.bye) (); // помилка!

</pre>
<p>В останньому рядку коду використовується умовний оператор ? , який визначає, який буде викликаний метод ' user.hi ' або ' user.bye) залежно від виконання умови. В даному випадку буде обраний user.hi.</p>
<p>Потім метод тут же викликається за допомогою дужок (). Але виклик не працює як годиться!</p>
<p>Ви можете бачити, що при виклику буде помилка, тому що значенням "this" всередині функції стає undefined (вважаємо, що у нас строгий режим).</p>
<p>Так працює (доступ до методу об'єкта через точку):</p>
<pre>user.hi();
</pre>

<p>Так вже не працює (викликається метод обчислюється):</p>
<pre>(user.name = = "Джон"? user.hi : user.bye) (); // помилка!
</pre>

<p>Чому? Якщо ми хочемо зрозуміти, чому так відбувається, давайте розберемося (заглянемо під капот), як працює виклик методів (obj.method()).</p>
<p>Придивившись ближче, у виразі ' obj.method ()' можна помітити дві операції:</p>
<ol>
<li>Спочатку оператор точка"."повертає властивість об'єкта - його метод (obj.method).</li>
<li>Потім дужки ' () ' викликають цей метод (виконується код методу).</li>
</ol>
<p>Отже, яким же чином інформація про 'this' передається з першої частини в другу?</p>
<p>Якщо ми помістимо ці операції в окремі рядки, то значення ' this', природно, буде втрачено:</p>
<pre>
let user = {
name: "Джон",
hi() { alert(this.name); }
};

// розділимо отримання методу об'єкта і його виклик в різних рядках
let hi = user.hi;
hi (); // помилка, тому що значенням this є undefined
</pre>

<p>
Тут 'hi = user.hi ' зберігає функцію в змінній, і далі в останньому рядку вона викликається повністю сама по собі, без об'єкта, так що немає 'this'.
</p>
<p>
Цей тип посилання (Reference Type) є внутрішнім типом. Ми не можемо явно використовувати його, але він використовується всередині мови.

Значення посилального типу - це "триплет": комбінація з трьох значень '(base, name, strict)', де:

''base' - це об'єкт.
''name' - це ім'я властивості об'єкта.
''strict' - це режим виконання. Є true, якщо діє строгий режим ('use strict').

Результатом доступу до властивості ' user.hi ' є не функція, а значення посилального типу. Для 'user.hi' в строгому режимі воно буде таким:
</p>

<pre>
// значення посилального типу (Reference Type)
(user, "hi", true)
</pre>
<p>Коли дужки ()застосовуються до значення посилального типу (відбувається виклик), то вони отримують повну інформацію про об'єкт і його метод, і можуть поставити правильнийthis(=userв даному випадку, по'base').</p>
<p>Посилальний тип-виключно внутрішній, проміжний, який використовується, щоб передати інформацію від точки . до викликаючих дужок ().</p>
<p>При будь-якій іншій операції, наприклад, присвоюванні ' hi = user.hi, посилальний тип замінюється на власне значення ' user.hi (функцію), і далі робота вже йде тільки з нею. Тому подальший виклик відбувається вже без 'this'.</p>
<p>Таким чином, значення 'thisпередається правильно, тільки якщо функція викликається безпосередньо з використанням синтаксису точки' obj.method () ' або квадратних дужокobj['method'] ()' (вони роблять те ж саме). Пізніше в цьому підручнику ми вивчимо різні варіанти вирішення проблеми втрати значення 'this'. Наприклад, такі як <a href="/bind#solution-2-bind">func.bind()</a>.</p>
<h2 id="-this-">У стрілочних функцій немає " this"</h2>
<p>Стрілочні функції особливі: у них немає свого "власного" this. Якщо ми використовуємо' this 'всередині стрілочної функції, то його значення береться із зовнішньої" нормальної " функції.</p>
<p>Наприклад, тут arrow () 'використовує значення' this із зовнішнього методу ' user.sayHi()':</p>
<pre>
let user = {
firstName: "Ілля",
sayHi() {
let arrow = () =&gt; alert(this.firstName);
arrow();
}
};
user.sayHi (); // Ілля
'''</pre>
<p>Це є особливістю стрілочних функцій. Вони корисні, коли ми насправді не хочемо мати окреме значення this, а хочемо брати його з зовнішнього контексту. Пізніше в розділі <info: arrow-functions> ми побачимо більше прикладів на цю тему.</p>
<h2 id="-">Разом</h2>
<ul>
<li>Функції, які знаходяться в об'єкті в якості його властивостей, називаються "методами".</li>
<li>Методи дозволяють об'єктам "діяти": object.doSomething().</li>
<li>Методи можуть посилатися на об'єкт через 'this'.</li>
</ul>
<p>Значення 'this' визначається під час виконання коду.</p>
<ul>
<li>При оголошенні будь-якої функції в ній можна використовувати 'this, але цей' this не має значення до тих пір, поки функція не буде викликана.</li>
<li>Ця функція може бути скопійована між об'єктами (з одного об'єкта в інший).</li>
<li>Коли функція викликається синтаксисом "методу" - object.method (), значенням ' this' під час виклику є об'єкт перед точкою.</li>
</ul>
<p>Також ще раз зауважимо, що стрілочні функції є особливими - у них немає this. Коли всередині стрілочної функції звертаються до 'this', то його значення береться зовні.</p>
<h1 id="-new-">Конструктори, створення об'єктів через " new"</h1>
<p>Звичайний синтаксис' {...} 'дозволяє створити тільки один об'єкт. Але найчастіше нам потрібно створити безліч однотипних об'єктів, таких як користувачі, елементи меню і т. д.</p>
<p>Це можна зробити за допомогою функції-конструктора і оператора "new".</p>
<h2 id="-">Функція-конструктор</h2>
<p>Функції-конструктори є звичайними функціями. Але є дві угоди:</p>
<ol>
<li>Ім'я функції-конструктора має починатися з великої літери.</li>
<li>Функція-конструктор повинна викликатися за допомогою оператора "new".</li>
</ol>
<p>Наприклад:</p>
<pre>
function User(name) {
this.name = name;
this.isAdmin = false;
}

let user = new User ("Вася");
alert(user.name); // Вася
alert(user.isAdmin); // false</p>
</pre>
<p>
Коли функція викликається як 'new User(...)', відбувається наступне:

1. Створюється новий порожній об'єкт, і він присвоюється 'this'.
2. Виконується код функції. Зазвичай він модифікує 'this', додає туди нові властивості.
3. Повертається значення 'this'.

Іншими словами, виклик ' new User (...' 'робить приблизно ось що:
</p>
<pre>
function User(name) {

// this = {}; (неявно)


// додає властивості до this
this.name = name;
this.isAdmin = false;


// return this; (неявно)

}
</pre>
<p>Тобто, результат виклику ' new User ("Вася")' - це той же об'єкт, що і:</p>
<pre>let user = {
name: "Вася",
isAdmin: false
};
</pre>

<p>Тепер, коли нам необхідно буде створити інших користувачів, ми можемо використовувати ' new User ("Маша"),
'new User ("Даша") і т.д. дана конструкція набагато зручніше і читабельніше, ніж кожен раз створювати літерал об'єкта. Це і є основною метою конструкторів-зручне повторне створення однотипних об'єктів.</p>
<p>Ще раз зауважимо: технічно будь-яка функція може бути використана як конструктор. Тобто, кожна функція може бути викликана за допомогою оператора new, і виконається алгоритм, зазначений вище в прикладі. Велика літера в назві функції є загальною угодою по іменуванню, вона як би підказує розробнику, що дана функція є функцією-конструктором, і її потрібно викликати через new.</p>
<p>''''smart header="new function() { ... }"
Якщо в нашому коді велика кількість рядків, що створюють один складний об'єкт, ми можемо обернути їх у функцію-конструктор наступним чином:</p>
<pre>let user = new function() {
this.name = " Вася";
this.isAdmin = false;

// ...інший код для створення користувача
// можлива будь-яка складна логіка і вирази
// локальні змінні і т. д.
};
</pre>

<p>Такий конструктор не може бути викликаний двічі, так як він ніде не зберігається, просто створюється і тут же викликається. Таким чином, такий метод створення дозволяє інкапсулювати код, який створює окремий об'єкт, але без можливості його повторного використання.</p>

<h2>Перевірка на виклик в режимі конструктора: new.target</h2>

<p>
"'smart header=" Просунута можливість"
Даний метод використовується дуже рідко. Ви можете пропустити цю секцію, якщо не хочете заглиблюватися в деталі мови.
'''

Використовуючи спеціальну властивість ' new 'target ' всередині функції, ми можемо перевірити, чи викликана функція за допомогою оператора 'new' або без нього.

У разі, якщо функція викликана за допомогою 'new', то в' new.target 'буде сама функція, в іншому випадку 'undefined'.
<p>
<pre>
function User() {
alert(new.target);
}

// без " new":

User(); // undefined


// с " new":

new User(); // function User { ... }

'''
</pre>
<p>
Це можна використовувати, щоб відрізнити звичайний виклик від виклику "в режимі конструктора". Зокрема, ось так можна зробити, щоб функцію можна було викликати як з, так і без 'new':
</p>
<pre>
function User(name) {
if (!new.target) {//у випадку, якщо ви викликали без оператора new
return new User(name); // ...додамо оператор new за вас
}

this.name = name;
}

let vasya = User ("Вася"); // переадресовує виклики на new User
alert(vasya.name); // Вася
'''
</pre>
<p>
Такий підхід іноді використовується в бібліотеках для створення більш гнучкого синтаксису, який дозволяє розробникам викликати функції за допомогою оператора 'new' або без нього.

Втім, це не дуже хороша практика, так як відсутність 'new' може ввести розробника в оману. З оператором ' new' ми точно знаємо, що в підсумку буде створено новий об'єкт.
</p>

<h2>Повернення значення з конструктора return</h2>

<p>
Зазвичай конструктори нічого не повертають явно. Їх завдання-записати все необхідне в ' this', який в підсумку стане результатом.

Але якщо 'return' все ж є, то застосовується просте правило:

- При виклику 'return' з об'єктом, буде повернуто об'єкт, а не 'this'.
- При виклику 'return' з примітивним значенням, примітивне значення буде відкинуто.

Іншими словами ' 'return' з об'єктом повертає об'єкт, в будь-якому іншому випадку конструктор поверне 'this'.

У прикладі нижче 'return 'повертає об'єкт замість' this':
</p>
<pre>
function BigUser() {

this.name = " Вася";

return { name:" Godzilla"}; // &lt; -- повертає цей об'єкт
}

alert (new BigUser (). name); // Godzilla, отримали цей об'єкт
'''
</pre>
<p>
А ось приклад з порожнім 'return' (або ми могли б поставити примітив після 'return', неважливо)
</p>
<pre>
function SmallUser() {

this.name = " Вася";

return; // &lt; -- повертає this
}

alert (new SmallUser (). name); // Вася
'''
</pre>
<p>
Зазвичай у конструкторів відсутня 'return'. У цьому блоці ми згадали особливу поведінку з об'єктами, що повертаються, щоб не залишати прогалин у вивченні мови.
</p>

<p>
""smart header=" відсутність дужок"
До речі, ми можемо не ставити дужки після ' new', якщо виклик конструктора йде без аргументів.
</p>
<pre>
let user = new User; // &lt; -- без дужок
// те ж, що і
let user = new User();
'''

Пропуск дужок вважається поганою практикою, але синтаксис мови таке дозволяє.
</pre>
<h2 id="-">Створення методів в конструкторі</h2>
<p>Використання конструкторів для створення об'єктів дає велику гнучкість. Можна передавати конструктору параметри, що визначають, як створювати об'єкт, і що в нього записувати.</p>
<p>У 'this ' ми можемо додавати не тільки властивості, але і методи.</p>
<p>Наприклад, у прикладі нижче, 'new Username)' створює об'єкт з даним ім'ям ' name і методом sayHi:</p>
<pre>
function User(name) {
this.name = name;
this.sayHi = function() {
alert ("мене звуть:" + this.name );
};
}

let vasya = new User ("Вася");
vasya.sayHi (); // мене звуть: Вася
vasya = {
name: "Вася",
sayHi: function() { ... }
}
</pre>
<p>
Для створення складних об'єктів є і більш "просунутий" синтаксис - [класи](info:classes), які ми розберемо пізніше.
</p>
<h2>Разом</h2>

- Функції-конструктори або просто конструктори є звичайними функціями, іменувати які слід з великої літери.
- Конструктори слід викликати за допомогою оператора ' new'. Такий виклик створює порожній 'this' на початку виконання і повертає заповнений в кінці.

Ми можемо використовувати Конструктори для створення безлічі схожих об'єктів.

JavaScript надає функції-Конструктори для безлічі вбудованих об'єктів мови: наприклад, 'Date', 'Set' та інших, які нам ще належить вивчити.

			<h2>Контрольні запитання</h2>
			<ol>
				
<li> </li>


			</ol>
		</div>
	</body>
	</html>